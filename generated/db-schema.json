{
  "access": {
    "auth": {
      "tables": {
        "clients_entities": "write",
        "roles_entities": "write"
      }
    },
    "github": {
      "tables": {
        "taskcluster_check_runs_entities": "write",
        "taskcluster_checks_to_tasks_entities": "write",
        "taskcluster_github_builds_entities": "write",
        "taskcluster_integration_owners_entities": "write"
      }
    },
    "hooks": {
      "tables": {
        "hooks_entities": "write",
        "last_fire_3_entities": "write",
        "queues_entities": "write"
      }
    },
    "index": {
      "tables": {
        "indexed_tasks_entities": "write",
        "namespaces_entities": "write"
      }
    },
    "notify": {
      "tables": {
        "denylisted_notification_entities": "write"
      }
    },
    "purge_cache": {
      "tables": {
        "cache_purges": "write"
      }
    },
    "queue": {
      "tables": {
        "azure_queue_messages": "write",
        "queue_artifacts_entities": "write",
        "queue_provisioner_entities": "write",
        "queue_task_dependency_entities": "write",
        "queue_task_group_active_sets_entities": "write",
        "queue_task_group_members_entities": "write",
        "queue_task_groups_entities": "write",
        "queue_task_requirement_entities": "write",
        "queue_tasks_entities": "write",
        "queue_worker_entities": "write",
        "queue_worker_type_entities": "write"
      }
    },
    "secrets": {
      "tables": {
        "secrets_entities": "write"
      }
    },
    "web_server": {
      "tables": {
        "access_token_table_entities": "write",
        "authorization_codes_table_entities": "write",
        "github_access_token_table_entities": "write",
        "session_storage_table_entities": "write"
      }
    },
    "worker_manager": {
      "tables": {
        "wmworker_pool_errors_entities": "write",
        "worker_pools": "write",
        "workers": "write"
      }
    }
  },
  "tables": {
    "access_token_table_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "authorization_codes_table_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "azure_queue_messages": {
      "expires": "timestamp with time zone not null",
      "inserted": "timestamp with time zone not null",
      "message_id": "uuid not null",
      "message_text": "text not null",
      "pop_receipt": "uuid",
      "queue_name": "text not null",
      "visible": "timestamp with time zone not null"
    },
    "cache_purges": {
      "before": "timestamp with time zone not null",
      "cache_name": "text not null",
      "etag": "uuid not null",
      "expires": "timestamp with time zone not null",
      "provisioner_id": "text not null",
      "worker_type": "text not null"
    },
    "clients_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "denylisted_notification_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "github_access_token_table_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "hooks_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "indexed_tasks_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "last_fire_3_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "namespaces_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_artifacts_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_provisioner_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_task_dependency_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_task_group_active_sets_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_task_group_members_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_task_groups_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_task_requirement_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_tasks_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_worker_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_worker_type_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queues_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "roles_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "secrets_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "session_storage_table_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "taskcluster_check_runs_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "taskcluster_checks_to_tasks_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "taskcluster_github_builds_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "taskcluster_integration_owners_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "wmworker_pool_errors_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "worker_pools": {
      "config": "jsonb not null",
      "created": "timestamp with time zone not null",
      "description": "text not null",
      "email_on_error": "boolean not null",
      "etag": "uuid not null",
      "last_modified": "timestamp with time zone not null",
      "owner": "text not null",
      "previous_provider_ids": "jsonb not null",
      "provider_data": "jsonb not null",
      "provider_id": "text not null",
      "worker_pool_id": "text not null"
    },
    "workers": {
      "capacity": "integer not null",
      "created": "timestamp with time zone not null",
      "etag": "uuid not null",
      "expires": "timestamp with time zone not null",
      "last_checked": "timestamp with time zone not null",
      "last_modified": "timestamp with time zone not null",
      "provider_data": "jsonb not null",
      "provider_id": "text not null",
      "secret": "jsonb",
      "state": "text not null",
      "worker_group": "text not null",
      "worker_id": "text not null",
      "worker_pool_id": "text not null"
    }
  },
  "versions": [
    {
      "downgradeScript": "begin\n  revoke select, insert, update, delete on widgets from $db_user_prefix$_notify;\n  drop table widgets;\nend",
      "methods": {
        "update_widgets": {
          "args": "name_in text",
          "body": "begin\n  insert into widgets (name) values (name_in);\n  return query select widgets.name from widgets;\nend",
          "deprecated": false,
          "description": "Temporary method to test infrastructure support fo database access",
          "mode": "write",
          "returns": "table (name text)",
          "serviceName": "notify"
        }
      },
      "migrationScript": "begin\n  create table widgets (\n    name text\n  );\n  grant select, insert, update, delete on widgets to $db_user_prefix$_notify;\nend",
      "version": 1
    },
    {
      "downgradeScript": "begin\n  revoke select, insert, update, delete on clients_entities from $db_user_prefix$_auth;\n  revoke select, insert, update, delete on roles_entities from $db_user_prefix$_auth;\n\n  revoke select, insert, update, delete on taskcluster_check_runs_entities from $db_user_prefix$_github;\n  revoke select, insert, update, delete on taskcluster_checks_to_tasks_entities from $db_user_prefix$_github;\n  revoke select, insert, update, delete on taskcluster_github_builds_entities from $db_user_prefix$_github;\n  revoke select, insert, update, delete on taskcluster_integration_owners_entities from $db_user_prefix$_github;\n\n  revoke select, insert, update, delete on hooks_entities from $db_user_prefix$_hooks;\n  revoke select, insert, update, delete on last_fire_3_entities from $db_user_prefix$_hooks;\n  revoke select, insert, update, delete on queues_entities from $db_user_prefix$_hooks;\n\n  revoke select, insert, update, delete on indexed_tasks_entities from $db_user_prefix$_index;\n  revoke select, insert, update, delete on namespaces_entities from $db_user_prefix$_index;\n\n  revoke select, insert, update, delete on denylisted_notification_entities from $db_user_prefix$_notify;\n\n  revoke select, insert, update, delete on cache_purges_entities from $db_user_prefix$_purge_cache;\n\n  revoke select, insert, update, delete on secrets_entities from $db_user_prefix$_secrets;\n\n  revoke select, insert, update, delete on access_token_table_entities from $db_user_prefix$_web_server;\n  revoke select, insert, update, delete on authorization_codes_table_entities from $db_user_prefix$_web_server;\n  revoke select, insert, update, delete on github_access_token_table_entities from $db_user_prefix$_web_server;\n  revoke select, insert, update, delete on session_storage_table_entities from $db_user_prefix$_web_server;\n\n  revoke select, insert, update, delete on wmworker_pool_errors_entities from $db_user_prefix$_worker_manager;\n  revoke select, insert, update, delete on wmworker_pools_entities from $db_user_prefix$_worker_manager;\n  revoke select, insert, update, delete on wmworkers_entities from $db_user_prefix$_worker_manager;\n\n  revoke select, insert, update, delete on queue_tasks_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_artifacts_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_task_groups_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_task_group_members_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_task_group_active_sets_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_task_requirement_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_task_dependency_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_worker_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_worker_type_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_provisioner_entities from $db_user_prefix$_queue;\n\n  drop table clients_entities;\n  drop table roles_entities;\n  drop table taskcluster_github_builds_entities;\n  drop table taskcluster_integration_owners_entities;\n  drop table taskcluster_checks_to_tasks_entities;\n  drop table taskcluster_check_runs_entities;\n  drop table hooks_entities;\n  drop table queues_entities;\n  drop table last_fire_3_entities;\n  drop table indexed_tasks_entities;\n  drop table namespaces_entities;\n  drop table denylisted_notification_entities;\n  drop table cache_purges_entities;\n  drop table queue_tasks_entities;\n  drop table queue_artifacts_entities;\n  drop table queue_task_groups_entities;\n  drop table queue_task_group_members_entities;\n  drop table queue_task_group_active_sets_entities;\n  drop table queue_task_requirement_entities;\n  drop table queue_task_dependency_entities;\n  drop table queue_worker_entities;\n  drop table queue_worker_type_entities;\n  drop table queue_provisioner_entities;\n  drop table secrets_entities;\n  drop table authorization_codes_table_entities;\n  drop table access_token_table_entities;\n  drop table session_storage_table_entities;\n  drop table github_access_token_table_entities;\n  drop table wmworkers_entities;\n  drop table wmworker_pools_entities;\n  drop table wmworker_pool_errors_entities;\nend",
      "methods": {
        "access_token_table_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into access_token_table_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, access_token_table_entities_create.version, new_etag)\n    where access_token_table_entities.partition_key = access_token_table_entities_create.pk and access_token_table_entities.row_key = access_token_table_entities_create.rk;\n  else\n    insert into access_token_table_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "web_server"
        },
        "access_token_table_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select access_token_table_entities.partition_key, access_token_table_entities.row_key, access_token_table_entities.value, access_token_table_entities.version,\n  access_token_table_entities.etag from access_token_table_entities\n  where access_token_table_entities.partition_key = access_token_table_entities_load.partition_key and access_token_table_entities.row_key = access_token_table_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "access_token_table_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update access_token_table_entities\n  set (value, version, etag) = (properties, access_token_table_entities_modify.version, new_etag)\n  where access_token_table_entities.partition_key = access_token_table_entities_modify.partition_key and access_token_table_entities.row_key = access_token_table_entities_modify.row_key and access_token_table_entities.etag = access_token_table_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform access_token_table_entities.etag from access_token_table_entities\n  where access_token_table_entities.partition_key = access_token_table_entities_modify.partition_key and access_token_table_entities.row_key = access_token_table_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "web_server"
        },
        "access_token_table_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from access_token_table_entities\n  where access_token_table_entities.partition_key = access_token_table_entities_remove.partition_key and access_token_table_entities.row_key = access_token_table_entities_remove.row_key\n  returning access_token_table_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "web_server"
        },
        "access_token_table_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select access_token_table_entities.partition_key, access_token_table_entities.row_key, access_token_table_entities.value, access_token_table_entities.version, access_token_table_entities.etag from access_token_table_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if access_token_table_entities_scan.pk is not null or access_token_table_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if access_token_table_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(access_token_table_entities_scan.pk);\n  end if;\n\n  if access_token_table_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(access_token_table_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by access_token_table_entities.partition_key, access_token_table_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "authorization_codes_table_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into authorization_codes_table_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, authorization_codes_table_entities_create.version, new_etag)\n    where authorization_codes_table_entities.partition_key = authorization_codes_table_entities_create.pk and authorization_codes_table_entities.row_key = authorization_codes_table_entities_create.rk;\n  else\n    insert into authorization_codes_table_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "web_server"
        },
        "authorization_codes_table_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select authorization_codes_table_entities.partition_key, authorization_codes_table_entities.row_key, authorization_codes_table_entities.value, authorization_codes_table_entities.version,\n  authorization_codes_table_entities.etag from authorization_codes_table_entities\n  where authorization_codes_table_entities.partition_key = authorization_codes_table_entities_load.partition_key and authorization_codes_table_entities.row_key = authorization_codes_table_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "authorization_codes_table_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update authorization_codes_table_entities\n  set (value, version, etag) = (properties, authorization_codes_table_entities_modify.version, new_etag)\n  where authorization_codes_table_entities.partition_key = authorization_codes_table_entities_modify.partition_key and authorization_codes_table_entities.row_key = authorization_codes_table_entities_modify.row_key and authorization_codes_table_entities.etag = authorization_codes_table_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform authorization_codes_table_entities.etag from authorization_codes_table_entities\n  where authorization_codes_table_entities.partition_key = authorization_codes_table_entities_modify.partition_key and authorization_codes_table_entities.row_key = authorization_codes_table_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "web_server"
        },
        "authorization_codes_table_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from authorization_codes_table_entities\n  where authorization_codes_table_entities.partition_key = authorization_codes_table_entities_remove.partition_key and authorization_codes_table_entities.row_key = authorization_codes_table_entities_remove.row_key\n  returning authorization_codes_table_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "web_server"
        },
        "authorization_codes_table_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select authorization_codes_table_entities.partition_key, authorization_codes_table_entities.row_key, authorization_codes_table_entities.value, authorization_codes_table_entities.version, authorization_codes_table_entities.etag from authorization_codes_table_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if authorization_codes_table_entities_scan.pk is not null or authorization_codes_table_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if authorization_codes_table_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(authorization_codes_table_entities_scan.pk);\n  end if;\n\n  if authorization_codes_table_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(authorization_codes_table_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by authorization_codes_table_entities.partition_key, authorization_codes_table_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "cache_purges_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into cache_purges_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, cache_purges_entities_create.version, new_etag)\n    where cache_purges_entities.partition_key = cache_purges_entities_create.pk and cache_purges_entities.row_key = cache_purges_entities_create.rk;\n  else\n    insert into cache_purges_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "purge_cache"
        },
        "cache_purges_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select cache_purges_entities.partition_key, cache_purges_entities.row_key, cache_purges_entities.value, cache_purges_entities.version,\n  cache_purges_entities.etag from cache_purges_entities\n  where cache_purges_entities.partition_key = cache_purges_entities_load.partition_key and cache_purges_entities.row_key = cache_purges_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "purge_cache"
        },
        "cache_purges_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update cache_purges_entities\n  set (value, version, etag) = (properties, cache_purges_entities_modify.version, new_etag)\n  where cache_purges_entities.partition_key = cache_purges_entities_modify.partition_key and cache_purges_entities.row_key = cache_purges_entities_modify.row_key and cache_purges_entities.etag = cache_purges_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform cache_purges_entities.etag from cache_purges_entities\n  where cache_purges_entities.partition_key = cache_purges_entities_modify.partition_key and cache_purges_entities.row_key = cache_purges_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "purge_cache"
        },
        "cache_purges_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from cache_purges_entities\n  where cache_purges_entities.partition_key = cache_purges_entities_remove.partition_key and cache_purges_entities.row_key = cache_purges_entities_remove.row_key\n  returning cache_purges_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "purge_cache"
        },
        "cache_purges_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select cache_purges_entities.partition_key, cache_purges_entities.row_key, cache_purges_entities.value, cache_purges_entities.version, cache_purges_entities.etag from cache_purges_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if cache_purges_entities_scan.pk is not null or cache_purges_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if cache_purges_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(cache_purges_entities_scan.pk);\n  end if;\n\n  if cache_purges_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(cache_purges_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by cache_purges_entities.partition_key, cache_purges_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "purge_cache"
        },
        "clients_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into clients_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, clients_entities_create.version, new_etag)\n    where clients_entities.partition_key = clients_entities_create.pk and clients_entities.row_key = clients_entities_create.rk;\n  else\n    insert into clients_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "auth"
        },
        "clients_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select clients_entities.partition_key, clients_entities.row_key, clients_entities.value, clients_entities.version,\n  clients_entities.etag from clients_entities\n  where clients_entities.partition_key = clients_entities_load.partition_key and clients_entities.row_key = clients_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "auth"
        },
        "clients_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update clients_entities\n  set (value, version, etag) = (properties, clients_entities_modify.version, new_etag)\n  where clients_entities.partition_key = clients_entities_modify.partition_key and clients_entities.row_key = clients_entities_modify.row_key and clients_entities.etag = clients_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform clients_entities.etag from clients_entities\n  where clients_entities.partition_key = clients_entities_modify.partition_key and clients_entities.row_key = clients_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "auth"
        },
        "clients_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from clients_entities\n  where clients_entities.partition_key = clients_entities_remove.partition_key and clients_entities.row_key = clients_entities_remove.row_key\n  returning clients_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "auth"
        },
        "clients_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select clients_entities.partition_key, clients_entities.row_key, clients_entities.value, clients_entities.version, clients_entities.etag from clients_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if clients_entities_scan.pk is not null or clients_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if clients_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(clients_entities_scan.pk);\n  end if;\n\n  if clients_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(clients_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by clients_entities.partition_key, clients_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "auth"
        },
        "denylisted_notification_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into denylisted_notification_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, denylisted_notification_entities_create.version, new_etag)\n    where denylisted_notification_entities.partition_key = denylisted_notification_entities_create.pk and denylisted_notification_entities.row_key = denylisted_notification_entities_create.rk;\n  else\n    insert into denylisted_notification_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "notify"
        },
        "denylisted_notification_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select denylisted_notification_entities.partition_key, denylisted_notification_entities.row_key, denylisted_notification_entities.value, denylisted_notification_entities.version,\n  denylisted_notification_entities.etag from denylisted_notification_entities\n  where denylisted_notification_entities.partition_key = denylisted_notification_entities_load.partition_key and denylisted_notification_entities.row_key = denylisted_notification_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "notify"
        },
        "denylisted_notification_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update denylisted_notification_entities\n  set (value, version, etag) = (properties, denylisted_notification_entities_modify.version, new_etag)\n  where denylisted_notification_entities.partition_key = denylisted_notification_entities_modify.partition_key and denylisted_notification_entities.row_key = denylisted_notification_entities_modify.row_key and denylisted_notification_entities.etag = denylisted_notification_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform denylisted_notification_entities.etag from denylisted_notification_entities\n  where denylisted_notification_entities.partition_key = denylisted_notification_entities_modify.partition_key and denylisted_notification_entities.row_key = denylisted_notification_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "notify"
        },
        "denylisted_notification_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from denylisted_notification_entities\n  where denylisted_notification_entities.partition_key = denylisted_notification_entities_remove.partition_key and denylisted_notification_entities.row_key = denylisted_notification_entities_remove.row_key\n  returning denylisted_notification_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "notify"
        },
        "denylisted_notification_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select denylisted_notification_entities.partition_key, denylisted_notification_entities.row_key, denylisted_notification_entities.value, denylisted_notification_entities.version, denylisted_notification_entities.etag from denylisted_notification_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if denylisted_notification_entities_scan.pk is not null or denylisted_notification_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if denylisted_notification_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(denylisted_notification_entities_scan.pk);\n  end if;\n\n  if denylisted_notification_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(denylisted_notification_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by denylisted_notification_entities.partition_key, denylisted_notification_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "notify"
        },
        "github_access_token_table_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into github_access_token_table_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, github_access_token_table_entities_create.version, new_etag)\n    where github_access_token_table_entities.partition_key = github_access_token_table_entities_create.pk and github_access_token_table_entities.row_key = github_access_token_table_entities_create.rk;\n  else\n    insert into github_access_token_table_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "web_server"
        },
        "github_access_token_table_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select github_access_token_table_entities.partition_key, github_access_token_table_entities.row_key, github_access_token_table_entities.value, github_access_token_table_entities.version,\n  github_access_token_table_entities.etag from github_access_token_table_entities\n  where github_access_token_table_entities.partition_key = github_access_token_table_entities_load.partition_key and github_access_token_table_entities.row_key = github_access_token_table_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "github_access_token_table_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update github_access_token_table_entities\n  set (value, version, etag) = (properties, github_access_token_table_entities_modify.version, new_etag)\n  where github_access_token_table_entities.partition_key = github_access_token_table_entities_modify.partition_key and github_access_token_table_entities.row_key = github_access_token_table_entities_modify.row_key and github_access_token_table_entities.etag = github_access_token_table_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform github_access_token_table_entities.etag from github_access_token_table_entities\n  where github_access_token_table_entities.partition_key = github_access_token_table_entities_modify.partition_key and github_access_token_table_entities.row_key = github_access_token_table_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "web_server"
        },
        "github_access_token_table_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from github_access_token_table_entities\n  where github_access_token_table_entities.partition_key = github_access_token_table_entities_remove.partition_key and github_access_token_table_entities.row_key = github_access_token_table_entities_remove.row_key\n  returning github_access_token_table_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "web_server"
        },
        "github_access_token_table_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select github_access_token_table_entities.partition_key, github_access_token_table_entities.row_key, github_access_token_table_entities.value, github_access_token_table_entities.version, github_access_token_table_entities.etag from github_access_token_table_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if github_access_token_table_entities_scan.pk is not null or github_access_token_table_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if github_access_token_table_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(github_access_token_table_entities_scan.pk);\n  end if;\n\n  if github_access_token_table_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(github_access_token_table_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by github_access_token_table_entities.partition_key, github_access_token_table_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "hooks_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into hooks_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, hooks_entities_create.version, new_etag)\n    where hooks_entities.partition_key = hooks_entities_create.pk and hooks_entities.row_key = hooks_entities_create.rk;\n  else\n    insert into hooks_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "hooks"
        },
        "hooks_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select hooks_entities.partition_key, hooks_entities.row_key, hooks_entities.value, hooks_entities.version,\n  hooks_entities.etag from hooks_entities\n  where hooks_entities.partition_key = hooks_entities_load.partition_key and hooks_entities.row_key = hooks_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "hooks_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update hooks_entities\n  set (value, version, etag) = (properties, hooks_entities_modify.version, new_etag)\n  where hooks_entities.partition_key = hooks_entities_modify.partition_key and hooks_entities.row_key = hooks_entities_modify.row_key and hooks_entities.etag = hooks_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform hooks_entities.etag from hooks_entities\n  where hooks_entities.partition_key = hooks_entities_modify.partition_key and hooks_entities.row_key = hooks_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "hooks"
        },
        "hooks_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from hooks_entities\n  where hooks_entities.partition_key = hooks_entities_remove.partition_key and hooks_entities.row_key = hooks_entities_remove.row_key\n  returning hooks_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "hooks"
        },
        "hooks_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select hooks_entities.partition_key, hooks_entities.row_key, hooks_entities.value, hooks_entities.version, hooks_entities.etag from hooks_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if hooks_entities_scan.pk is not null or hooks_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if hooks_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(hooks_entities_scan.pk);\n  end if;\n\n  if hooks_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(hooks_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by hooks_entities.partition_key, hooks_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "indexed_tasks_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into indexed_tasks_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, indexed_tasks_entities_create.version, new_etag)\n    where indexed_tasks_entities.partition_key = indexed_tasks_entities_create.pk and indexed_tasks_entities.row_key = indexed_tasks_entities_create.rk;\n  else\n    insert into indexed_tasks_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "index"
        },
        "indexed_tasks_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select indexed_tasks_entities.partition_key, indexed_tasks_entities.row_key, indexed_tasks_entities.value, indexed_tasks_entities.version,\n  indexed_tasks_entities.etag from indexed_tasks_entities\n  where indexed_tasks_entities.partition_key = indexed_tasks_entities_load.partition_key and indexed_tasks_entities.row_key = indexed_tasks_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "index"
        },
        "indexed_tasks_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update indexed_tasks_entities\n  set (value, version, etag) = (properties, indexed_tasks_entities_modify.version, new_etag)\n  where indexed_tasks_entities.partition_key = indexed_tasks_entities_modify.partition_key and indexed_tasks_entities.row_key = indexed_tasks_entities_modify.row_key and indexed_tasks_entities.etag = indexed_tasks_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform indexed_tasks_entities.etag from indexed_tasks_entities\n  where indexed_tasks_entities.partition_key = indexed_tasks_entities_modify.partition_key and indexed_tasks_entities.row_key = indexed_tasks_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "index"
        },
        "indexed_tasks_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from indexed_tasks_entities\n  where indexed_tasks_entities.partition_key = indexed_tasks_entities_remove.partition_key and indexed_tasks_entities.row_key = indexed_tasks_entities_remove.row_key\n  returning indexed_tasks_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "index"
        },
        "indexed_tasks_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select indexed_tasks_entities.partition_key, indexed_tasks_entities.row_key, indexed_tasks_entities.value, indexed_tasks_entities.version, indexed_tasks_entities.etag from indexed_tasks_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if indexed_tasks_entities_scan.pk is not null or indexed_tasks_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if indexed_tasks_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(indexed_tasks_entities_scan.pk);\n  end if;\n\n  if indexed_tasks_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(indexed_tasks_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by indexed_tasks_entities.partition_key, indexed_tasks_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "index"
        },
        "last_fire_3_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into last_fire_3_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, last_fire_3_entities_create.version, new_etag)\n    where last_fire_3_entities.partition_key = last_fire_3_entities_create.pk and last_fire_3_entities.row_key = last_fire_3_entities_create.rk;\n  else\n    insert into last_fire_3_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "hooks"
        },
        "last_fire_3_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select last_fire_3_entities.partition_key, last_fire_3_entities.row_key, last_fire_3_entities.value, last_fire_3_entities.version,\n  last_fire_3_entities.etag from last_fire_3_entities\n  where last_fire_3_entities.partition_key = last_fire_3_entities_load.partition_key and last_fire_3_entities.row_key = last_fire_3_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "last_fire_3_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update last_fire_3_entities\n  set (value, version, etag) = (properties, last_fire_3_entities_modify.version, new_etag)\n  where last_fire_3_entities.partition_key = last_fire_3_entities_modify.partition_key and last_fire_3_entities.row_key = last_fire_3_entities_modify.row_key and last_fire_3_entities.etag = last_fire_3_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform last_fire_3_entities.etag from last_fire_3_entities\n  where last_fire_3_entities.partition_key = last_fire_3_entities_modify.partition_key and last_fire_3_entities.row_key = last_fire_3_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "hooks"
        },
        "last_fire_3_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from last_fire_3_entities\n  where last_fire_3_entities.partition_key = last_fire_3_entities_remove.partition_key and last_fire_3_entities.row_key = last_fire_3_entities_remove.row_key\n  returning last_fire_3_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "hooks"
        },
        "last_fire_3_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select last_fire_3_entities.partition_key, last_fire_3_entities.row_key, last_fire_3_entities.value, last_fire_3_entities.version, last_fire_3_entities.etag from last_fire_3_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if last_fire_3_entities_scan.pk is not null or last_fire_3_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if last_fire_3_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(last_fire_3_entities_scan.pk);\n  end if;\n\n  if last_fire_3_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(last_fire_3_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by last_fire_3_entities.partition_key, last_fire_3_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "namespaces_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into namespaces_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, namespaces_entities_create.version, new_etag)\n    where namespaces_entities.partition_key = namespaces_entities_create.pk and namespaces_entities.row_key = namespaces_entities_create.rk;\n  else\n    insert into namespaces_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "index"
        },
        "namespaces_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select namespaces_entities.partition_key, namespaces_entities.row_key, namespaces_entities.value, namespaces_entities.version,\n  namespaces_entities.etag from namespaces_entities\n  where namespaces_entities.partition_key = namespaces_entities_load.partition_key and namespaces_entities.row_key = namespaces_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "index"
        },
        "namespaces_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update namespaces_entities\n  set (value, version, etag) = (properties, namespaces_entities_modify.version, new_etag)\n  where namespaces_entities.partition_key = namespaces_entities_modify.partition_key and namespaces_entities.row_key = namespaces_entities_modify.row_key and namespaces_entities.etag = namespaces_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform namespaces_entities.etag from namespaces_entities\n  where namespaces_entities.partition_key = namespaces_entities_modify.partition_key and namespaces_entities.row_key = namespaces_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "index"
        },
        "namespaces_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from namespaces_entities\n  where namespaces_entities.partition_key = namespaces_entities_remove.partition_key and namespaces_entities.row_key = namespaces_entities_remove.row_key\n  returning namespaces_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "index"
        },
        "namespaces_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select namespaces_entities.partition_key, namespaces_entities.row_key, namespaces_entities.value, namespaces_entities.version, namespaces_entities.etag from namespaces_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if namespaces_entities_scan.pk is not null or namespaces_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if namespaces_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(namespaces_entities_scan.pk);\n  end if;\n\n  if namespaces_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(namespaces_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by namespaces_entities.partition_key, namespaces_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "index"
        },
        "queue_artifacts_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_artifacts_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_artifacts_entities_create.version, new_etag)\n    where queue_artifacts_entities.partition_key = queue_artifacts_entities_create.pk and queue_artifacts_entities.row_key = queue_artifacts_entities_create.rk;\n  else\n    insert into queue_artifacts_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_artifacts_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_artifacts_entities.partition_key, queue_artifacts_entities.row_key, queue_artifacts_entities.value, queue_artifacts_entities.version,\n  queue_artifacts_entities.etag from queue_artifacts_entities\n  where queue_artifacts_entities.partition_key = queue_artifacts_entities_load.partition_key and queue_artifacts_entities.row_key = queue_artifacts_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_artifacts_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_artifacts_entities\n  set (value, version, etag) = (properties, queue_artifacts_entities_modify.version, new_etag)\n  where queue_artifacts_entities.partition_key = queue_artifacts_entities_modify.partition_key and queue_artifacts_entities.row_key = queue_artifacts_entities_modify.row_key and queue_artifacts_entities.etag = queue_artifacts_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_artifacts_entities.etag from queue_artifacts_entities\n  where queue_artifacts_entities.partition_key = queue_artifacts_entities_modify.partition_key and queue_artifacts_entities.row_key = queue_artifacts_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_artifacts_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_artifacts_entities\n  where queue_artifacts_entities.partition_key = queue_artifacts_entities_remove.partition_key and queue_artifacts_entities.row_key = queue_artifacts_entities_remove.row_key\n  returning queue_artifacts_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_artifacts_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_artifacts_entities.partition_key, queue_artifacts_entities.row_key, queue_artifacts_entities.value, queue_artifacts_entities.version, queue_artifacts_entities.etag from queue_artifacts_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_artifacts_entities_scan.pk is not null or queue_artifacts_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_artifacts_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_artifacts_entities_scan.pk);\n  end if;\n\n  if queue_artifacts_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_artifacts_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_artifacts_entities.partition_key, queue_artifacts_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_provisioner_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_provisioner_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_provisioner_entities_create.version, new_etag)\n    where queue_provisioner_entities.partition_key = queue_provisioner_entities_create.pk and queue_provisioner_entities.row_key = queue_provisioner_entities_create.rk;\n  else\n    insert into queue_provisioner_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_provisioner_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_provisioner_entities.partition_key, queue_provisioner_entities.row_key, queue_provisioner_entities.value, queue_provisioner_entities.version,\n  queue_provisioner_entities.etag from queue_provisioner_entities\n  where queue_provisioner_entities.partition_key = queue_provisioner_entities_load.partition_key and queue_provisioner_entities.row_key = queue_provisioner_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_provisioner_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_provisioner_entities\n  set (value, version, etag) = (properties, queue_provisioner_entities_modify.version, new_etag)\n  where queue_provisioner_entities.partition_key = queue_provisioner_entities_modify.partition_key and queue_provisioner_entities.row_key = queue_provisioner_entities_modify.row_key and queue_provisioner_entities.etag = queue_provisioner_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_provisioner_entities.etag from queue_provisioner_entities\n  where queue_provisioner_entities.partition_key = queue_provisioner_entities_modify.partition_key and queue_provisioner_entities.row_key = queue_provisioner_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_provisioner_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_provisioner_entities\n  where queue_provisioner_entities.partition_key = queue_provisioner_entities_remove.partition_key and queue_provisioner_entities.row_key = queue_provisioner_entities_remove.row_key\n  returning queue_provisioner_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_provisioner_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_provisioner_entities.partition_key, queue_provisioner_entities.row_key, queue_provisioner_entities.value, queue_provisioner_entities.version, queue_provisioner_entities.etag from queue_provisioner_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_provisioner_entities_scan.pk is not null or queue_provisioner_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_provisioner_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_provisioner_entities_scan.pk);\n  end if;\n\n  if queue_provisioner_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_provisioner_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_provisioner_entities.partition_key, queue_provisioner_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_dependency_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_task_dependency_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_task_dependency_entities_create.version, new_etag)\n    where queue_task_dependency_entities.partition_key = queue_task_dependency_entities_create.pk and queue_task_dependency_entities.row_key = queue_task_dependency_entities_create.rk;\n  else\n    insert into queue_task_dependency_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_task_dependency_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_task_dependency_entities.partition_key, queue_task_dependency_entities.row_key, queue_task_dependency_entities.value, queue_task_dependency_entities.version,\n  queue_task_dependency_entities.etag from queue_task_dependency_entities\n  where queue_task_dependency_entities.partition_key = queue_task_dependency_entities_load.partition_key and queue_task_dependency_entities.row_key = queue_task_dependency_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_dependency_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_task_dependency_entities\n  set (value, version, etag) = (properties, queue_task_dependency_entities_modify.version, new_etag)\n  where queue_task_dependency_entities.partition_key = queue_task_dependency_entities_modify.partition_key and queue_task_dependency_entities.row_key = queue_task_dependency_entities_modify.row_key and queue_task_dependency_entities.etag = queue_task_dependency_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_task_dependency_entities.etag from queue_task_dependency_entities\n  where queue_task_dependency_entities.partition_key = queue_task_dependency_entities_modify.partition_key and queue_task_dependency_entities.row_key = queue_task_dependency_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_dependency_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_task_dependency_entities\n  where queue_task_dependency_entities.partition_key = queue_task_dependency_entities_remove.partition_key and queue_task_dependency_entities.row_key = queue_task_dependency_entities_remove.row_key\n  returning queue_task_dependency_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_dependency_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_dependency_entities.partition_key, queue_task_dependency_entities.row_key, queue_task_dependency_entities.value, queue_task_dependency_entities.version, queue_task_dependency_entities.etag from queue_task_dependency_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_task_dependency_entities_scan.pk is not null or queue_task_dependency_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_dependency_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_dependency_entities_scan.pk);\n  end if;\n\n  if queue_task_dependency_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_dependency_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_dependency_entities.partition_key, queue_task_dependency_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_active_sets_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_task_group_active_sets_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_task_group_active_sets_entities_create.version, new_etag)\n    where queue_task_group_active_sets_entities.partition_key = queue_task_group_active_sets_entities_create.pk and queue_task_group_active_sets_entities.row_key = queue_task_group_active_sets_entities_create.rk;\n  else\n    insert into queue_task_group_active_sets_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_task_group_active_sets_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_task_group_active_sets_entities.partition_key, queue_task_group_active_sets_entities.row_key, queue_task_group_active_sets_entities.value, queue_task_group_active_sets_entities.version,\n  queue_task_group_active_sets_entities.etag from queue_task_group_active_sets_entities\n  where queue_task_group_active_sets_entities.partition_key = queue_task_group_active_sets_entities_load.partition_key and queue_task_group_active_sets_entities.row_key = queue_task_group_active_sets_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_active_sets_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_task_group_active_sets_entities\n  set (value, version, etag) = (properties, queue_task_group_active_sets_entities_modify.version, new_etag)\n  where queue_task_group_active_sets_entities.partition_key = queue_task_group_active_sets_entities_modify.partition_key and queue_task_group_active_sets_entities.row_key = queue_task_group_active_sets_entities_modify.row_key and queue_task_group_active_sets_entities.etag = queue_task_group_active_sets_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_task_group_active_sets_entities.etag from queue_task_group_active_sets_entities\n  where queue_task_group_active_sets_entities.partition_key = queue_task_group_active_sets_entities_modify.partition_key and queue_task_group_active_sets_entities.row_key = queue_task_group_active_sets_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_active_sets_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_task_group_active_sets_entities\n  where queue_task_group_active_sets_entities.partition_key = queue_task_group_active_sets_entities_remove.partition_key and queue_task_group_active_sets_entities.row_key = queue_task_group_active_sets_entities_remove.row_key\n  returning queue_task_group_active_sets_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_active_sets_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_group_active_sets_entities.partition_key, queue_task_group_active_sets_entities.row_key, queue_task_group_active_sets_entities.value, queue_task_group_active_sets_entities.version, queue_task_group_active_sets_entities.etag from queue_task_group_active_sets_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_task_group_active_sets_entities_scan.pk is not null or queue_task_group_active_sets_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_group_active_sets_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_group_active_sets_entities_scan.pk);\n  end if;\n\n  if queue_task_group_active_sets_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_group_active_sets_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_group_active_sets_entities.partition_key, queue_task_group_active_sets_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_members_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_task_group_members_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_task_group_members_entities_create.version, new_etag)\n    where queue_task_group_members_entities.partition_key = queue_task_group_members_entities_create.pk and queue_task_group_members_entities.row_key = queue_task_group_members_entities_create.rk;\n  else\n    insert into queue_task_group_members_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_task_group_members_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_task_group_members_entities.partition_key, queue_task_group_members_entities.row_key, queue_task_group_members_entities.value, queue_task_group_members_entities.version,\n  queue_task_group_members_entities.etag from queue_task_group_members_entities\n  where queue_task_group_members_entities.partition_key = queue_task_group_members_entities_load.partition_key and queue_task_group_members_entities.row_key = queue_task_group_members_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_members_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_task_group_members_entities\n  set (value, version, etag) = (properties, queue_task_group_members_entities_modify.version, new_etag)\n  where queue_task_group_members_entities.partition_key = queue_task_group_members_entities_modify.partition_key and queue_task_group_members_entities.row_key = queue_task_group_members_entities_modify.row_key and queue_task_group_members_entities.etag = queue_task_group_members_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_task_group_members_entities.etag from queue_task_group_members_entities\n  where queue_task_group_members_entities.partition_key = queue_task_group_members_entities_modify.partition_key and queue_task_group_members_entities.row_key = queue_task_group_members_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_members_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_task_group_members_entities\n  where queue_task_group_members_entities.partition_key = queue_task_group_members_entities_remove.partition_key and queue_task_group_members_entities.row_key = queue_task_group_members_entities_remove.row_key\n  returning queue_task_group_members_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_members_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_group_members_entities.partition_key, queue_task_group_members_entities.row_key, queue_task_group_members_entities.value, queue_task_group_members_entities.version, queue_task_group_members_entities.etag from queue_task_group_members_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_task_group_members_entities_scan.pk is not null or queue_task_group_members_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_group_members_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_group_members_entities_scan.pk);\n  end if;\n\n  if queue_task_group_members_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_group_members_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_group_members_entities.partition_key, queue_task_group_members_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_groups_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_task_groups_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_task_groups_entities_create.version, new_etag)\n    where queue_task_groups_entities.partition_key = queue_task_groups_entities_create.pk and queue_task_groups_entities.row_key = queue_task_groups_entities_create.rk;\n  else\n    insert into queue_task_groups_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_task_groups_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_task_groups_entities.partition_key, queue_task_groups_entities.row_key, queue_task_groups_entities.value, queue_task_groups_entities.version,\n  queue_task_groups_entities.etag from queue_task_groups_entities\n  where queue_task_groups_entities.partition_key = queue_task_groups_entities_load.partition_key and queue_task_groups_entities.row_key = queue_task_groups_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_groups_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_task_groups_entities\n  set (value, version, etag) = (properties, queue_task_groups_entities_modify.version, new_etag)\n  where queue_task_groups_entities.partition_key = queue_task_groups_entities_modify.partition_key and queue_task_groups_entities.row_key = queue_task_groups_entities_modify.row_key and queue_task_groups_entities.etag = queue_task_groups_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_task_groups_entities.etag from queue_task_groups_entities\n  where queue_task_groups_entities.partition_key = queue_task_groups_entities_modify.partition_key and queue_task_groups_entities.row_key = queue_task_groups_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_groups_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_task_groups_entities\n  where queue_task_groups_entities.partition_key = queue_task_groups_entities_remove.partition_key and queue_task_groups_entities.row_key = queue_task_groups_entities_remove.row_key\n  returning queue_task_groups_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_groups_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_groups_entities.partition_key, queue_task_groups_entities.row_key, queue_task_groups_entities.value, queue_task_groups_entities.version, queue_task_groups_entities.etag from queue_task_groups_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_task_groups_entities_scan.pk is not null or queue_task_groups_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_groups_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_groups_entities_scan.pk);\n  end if;\n\n  if queue_task_groups_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_groups_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_groups_entities.partition_key, queue_task_groups_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_requirement_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_task_requirement_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_task_requirement_entities_create.version, new_etag)\n    where queue_task_requirement_entities.partition_key = queue_task_requirement_entities_create.pk and queue_task_requirement_entities.row_key = queue_task_requirement_entities_create.rk;\n  else\n    insert into queue_task_requirement_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_task_requirement_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_task_requirement_entities.partition_key, queue_task_requirement_entities.row_key, queue_task_requirement_entities.value, queue_task_requirement_entities.version,\n  queue_task_requirement_entities.etag from queue_task_requirement_entities\n  where queue_task_requirement_entities.partition_key = queue_task_requirement_entities_load.partition_key and queue_task_requirement_entities.row_key = queue_task_requirement_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_requirement_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_task_requirement_entities\n  set (value, version, etag) = (properties, queue_task_requirement_entities_modify.version, new_etag)\n  where queue_task_requirement_entities.partition_key = queue_task_requirement_entities_modify.partition_key and queue_task_requirement_entities.row_key = queue_task_requirement_entities_modify.row_key and queue_task_requirement_entities.etag = queue_task_requirement_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_task_requirement_entities.etag from queue_task_requirement_entities\n  where queue_task_requirement_entities.partition_key = queue_task_requirement_entities_modify.partition_key and queue_task_requirement_entities.row_key = queue_task_requirement_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_requirement_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_task_requirement_entities\n  where queue_task_requirement_entities.partition_key = queue_task_requirement_entities_remove.partition_key and queue_task_requirement_entities.row_key = queue_task_requirement_entities_remove.row_key\n  returning queue_task_requirement_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_requirement_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_requirement_entities.partition_key, queue_task_requirement_entities.row_key, queue_task_requirement_entities.value, queue_task_requirement_entities.version, queue_task_requirement_entities.etag from queue_task_requirement_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_task_requirement_entities_scan.pk is not null or queue_task_requirement_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_requirement_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_requirement_entities_scan.pk);\n  end if;\n\n  if queue_task_requirement_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_requirement_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_requirement_entities.partition_key, queue_task_requirement_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_tasks_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_tasks_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_tasks_entities_create.version, new_etag)\n    where queue_tasks_entities.partition_key = queue_tasks_entities_create.pk and queue_tasks_entities.row_key = queue_tasks_entities_create.rk;\n  else\n    insert into queue_tasks_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_tasks_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_tasks_entities.partition_key, queue_tasks_entities.row_key, queue_tasks_entities.value, queue_tasks_entities.version,\n  queue_tasks_entities.etag from queue_tasks_entities\n  where queue_tasks_entities.partition_key = queue_tasks_entities_load.partition_key and queue_tasks_entities.row_key = queue_tasks_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_tasks_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_tasks_entities\n  set (value, version, etag) = (properties, queue_tasks_entities_modify.version, new_etag)\n  where queue_tasks_entities.partition_key = queue_tasks_entities_modify.partition_key and queue_tasks_entities.row_key = queue_tasks_entities_modify.row_key and queue_tasks_entities.etag = queue_tasks_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_tasks_entities.etag from queue_tasks_entities\n  where queue_tasks_entities.partition_key = queue_tasks_entities_modify.partition_key and queue_tasks_entities.row_key = queue_tasks_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_tasks_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_tasks_entities\n  where queue_tasks_entities.partition_key = queue_tasks_entities_remove.partition_key and queue_tasks_entities.row_key = queue_tasks_entities_remove.row_key\n  returning queue_tasks_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_tasks_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_tasks_entities.partition_key, queue_tasks_entities.row_key, queue_tasks_entities.value, queue_tasks_entities.version, queue_tasks_entities.etag from queue_tasks_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_tasks_entities_scan.pk is not null or queue_tasks_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_tasks_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_tasks_entities_scan.pk);\n  end if;\n\n  if queue_tasks_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_tasks_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_tasks_entities.partition_key, queue_tasks_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_worker_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_worker_entities_create.version, new_etag)\n    where queue_worker_entities.partition_key = queue_worker_entities_create.pk and queue_worker_entities.row_key = queue_worker_entities_create.rk;\n  else\n    insert into queue_worker_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_worker_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_worker_entities.partition_key, queue_worker_entities.row_key, queue_worker_entities.value, queue_worker_entities.version,\n  queue_worker_entities.etag from queue_worker_entities\n  where queue_worker_entities.partition_key = queue_worker_entities_load.partition_key and queue_worker_entities.row_key = queue_worker_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_worker_entities\n  set (value, version, etag) = (properties, queue_worker_entities_modify.version, new_etag)\n  where queue_worker_entities.partition_key = queue_worker_entities_modify.partition_key and queue_worker_entities.row_key = queue_worker_entities_modify.row_key and queue_worker_entities.etag = queue_worker_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_worker_entities.etag from queue_worker_entities\n  where queue_worker_entities.partition_key = queue_worker_entities_modify.partition_key and queue_worker_entities.row_key = queue_worker_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_worker_entities\n  where queue_worker_entities.partition_key = queue_worker_entities_remove.partition_key and queue_worker_entities.row_key = queue_worker_entities_remove.row_key\n  returning queue_worker_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_worker_entities.partition_key, queue_worker_entities.row_key, queue_worker_entities.value, queue_worker_entities.version, queue_worker_entities.etag from queue_worker_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_worker_entities_scan.pk is not null or queue_worker_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_worker_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_worker_entities_scan.pk);\n  end if;\n\n  if queue_worker_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_worker_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_worker_entities.partition_key, queue_worker_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_type_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_worker_type_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_worker_type_entities_create.version, new_etag)\n    where queue_worker_type_entities.partition_key = queue_worker_type_entities_create.pk and queue_worker_type_entities.row_key = queue_worker_type_entities_create.rk;\n  else\n    insert into queue_worker_type_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_worker_type_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_worker_type_entities.partition_key, queue_worker_type_entities.row_key, queue_worker_type_entities.value, queue_worker_type_entities.version,\n  queue_worker_type_entities.etag from queue_worker_type_entities\n  where queue_worker_type_entities.partition_key = queue_worker_type_entities_load.partition_key and queue_worker_type_entities.row_key = queue_worker_type_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_type_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_worker_type_entities\n  set (value, version, etag) = (properties, queue_worker_type_entities_modify.version, new_etag)\n  where queue_worker_type_entities.partition_key = queue_worker_type_entities_modify.partition_key and queue_worker_type_entities.row_key = queue_worker_type_entities_modify.row_key and queue_worker_type_entities.etag = queue_worker_type_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_worker_type_entities.etag from queue_worker_type_entities\n  where queue_worker_type_entities.partition_key = queue_worker_type_entities_modify.partition_key and queue_worker_type_entities.row_key = queue_worker_type_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_type_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_worker_type_entities\n  where queue_worker_type_entities.partition_key = queue_worker_type_entities_remove.partition_key and queue_worker_type_entities.row_key = queue_worker_type_entities_remove.row_key\n  returning queue_worker_type_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_type_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_worker_type_entities.partition_key, queue_worker_type_entities.row_key, queue_worker_type_entities.value, queue_worker_type_entities.version, queue_worker_type_entities.etag from queue_worker_type_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_worker_type_entities_scan.pk is not null or queue_worker_type_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_worker_type_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_worker_type_entities_scan.pk);\n  end if;\n\n  if queue_worker_type_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_worker_type_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_worker_type_entities.partition_key, queue_worker_type_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queues_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queues_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queues_entities_create.version, new_etag)\n    where queues_entities.partition_key = queues_entities_create.pk and queues_entities.row_key = queues_entities_create.rk;\n  else\n    insert into queues_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "hooks"
        },
        "queues_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queues_entities.partition_key, queues_entities.row_key, queues_entities.value, queues_entities.version,\n  queues_entities.etag from queues_entities\n  where queues_entities.partition_key = queues_entities_load.partition_key and queues_entities.row_key = queues_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "queues_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queues_entities\n  set (value, version, etag) = (properties, queues_entities_modify.version, new_etag)\n  where queues_entities.partition_key = queues_entities_modify.partition_key and queues_entities.row_key = queues_entities_modify.row_key and queues_entities.etag = queues_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queues_entities.etag from queues_entities\n  where queues_entities.partition_key = queues_entities_modify.partition_key and queues_entities.row_key = queues_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "hooks"
        },
        "queues_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queues_entities\n  where queues_entities.partition_key = queues_entities_remove.partition_key and queues_entities.row_key = queues_entities_remove.row_key\n  returning queues_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "hooks"
        },
        "queues_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queues_entities.partition_key, queues_entities.row_key, queues_entities.value, queues_entities.version, queues_entities.etag from queues_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queues_entities_scan.pk is not null or queues_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queues_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queues_entities_scan.pk);\n  end if;\n\n  if queues_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queues_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queues_entities.partition_key, queues_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "roles_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into roles_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, roles_entities_create.version, new_etag)\n    where roles_entities.partition_key = roles_entities_create.pk and roles_entities.row_key = roles_entities_create.rk;\n  else\n    insert into roles_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "auth"
        },
        "roles_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select roles_entities.partition_key, roles_entities.row_key, roles_entities.value, roles_entities.version,\n  roles_entities.etag from roles_entities\n  where roles_entities.partition_key = roles_entities_load.partition_key and roles_entities.row_key = roles_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "auth"
        },
        "roles_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update roles_entities\n  set (value, version, etag) = (properties, roles_entities_modify.version, new_etag)\n  where roles_entities.partition_key = roles_entities_modify.partition_key and roles_entities.row_key = roles_entities_modify.row_key and roles_entities.etag = roles_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform roles_entities.etag from roles_entities\n  where roles_entities.partition_key = roles_entities_modify.partition_key and roles_entities.row_key = roles_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "auth"
        },
        "roles_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from roles_entities\n  where roles_entities.partition_key = roles_entities_remove.partition_key and roles_entities.row_key = roles_entities_remove.row_key\n  returning roles_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "auth"
        },
        "roles_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select roles_entities.partition_key, roles_entities.row_key, roles_entities.value, roles_entities.version, roles_entities.etag from roles_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if roles_entities_scan.pk is not null or roles_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if roles_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(roles_entities_scan.pk);\n  end if;\n\n  if roles_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(roles_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by roles_entities.partition_key, roles_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "auth"
        },
        "secrets_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into secrets_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, secrets_entities_create.version, new_etag)\n    where secrets_entities.partition_key = secrets_entities_create.pk and secrets_entities.row_key = secrets_entities_create.rk;\n  else\n    insert into secrets_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "secrets"
        },
        "secrets_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select secrets_entities.partition_key, secrets_entities.row_key, secrets_entities.value, secrets_entities.version,\n  secrets_entities.etag from secrets_entities\n  where secrets_entities.partition_key = secrets_entities_load.partition_key and secrets_entities.row_key = secrets_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "secrets"
        },
        "secrets_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update secrets_entities\n  set (value, version, etag) = (properties, secrets_entities_modify.version, new_etag)\n  where secrets_entities.partition_key = secrets_entities_modify.partition_key and secrets_entities.row_key = secrets_entities_modify.row_key and secrets_entities.etag = secrets_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform secrets_entities.etag from secrets_entities\n  where secrets_entities.partition_key = secrets_entities_modify.partition_key and secrets_entities.row_key = secrets_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "secrets"
        },
        "secrets_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from secrets_entities\n  where secrets_entities.partition_key = secrets_entities_remove.partition_key and secrets_entities.row_key = secrets_entities_remove.row_key\n  returning secrets_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "secrets"
        },
        "secrets_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select secrets_entities.partition_key, secrets_entities.row_key, secrets_entities.value, secrets_entities.version, secrets_entities.etag from secrets_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if secrets_entities_scan.pk is not null or secrets_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if secrets_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(secrets_entities_scan.pk);\n  end if;\n\n  if secrets_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(secrets_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by secrets_entities.partition_key, secrets_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "secrets"
        },
        "session_storage_table_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into session_storage_table_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, session_storage_table_entities_create.version, new_etag)\n    where session_storage_table_entities.partition_key = session_storage_table_entities_create.pk and session_storage_table_entities.row_key = session_storage_table_entities_create.rk;\n  else\n    insert into session_storage_table_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "web_server"
        },
        "session_storage_table_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select session_storage_table_entities.partition_key, session_storage_table_entities.row_key, session_storage_table_entities.value, session_storage_table_entities.version,\n  session_storage_table_entities.etag from session_storage_table_entities\n  where session_storage_table_entities.partition_key = session_storage_table_entities_load.partition_key and session_storage_table_entities.row_key = session_storage_table_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "session_storage_table_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update session_storage_table_entities\n  set (value, version, etag) = (properties, session_storage_table_entities_modify.version, new_etag)\n  where session_storage_table_entities.partition_key = session_storage_table_entities_modify.partition_key and session_storage_table_entities.row_key = session_storage_table_entities_modify.row_key and session_storage_table_entities.etag = session_storage_table_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform session_storage_table_entities.etag from session_storage_table_entities\n  where session_storage_table_entities.partition_key = session_storage_table_entities_modify.partition_key and session_storage_table_entities.row_key = session_storage_table_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "web_server"
        },
        "session_storage_table_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from session_storage_table_entities\n  where session_storage_table_entities.partition_key = session_storage_table_entities_remove.partition_key and session_storage_table_entities.row_key = session_storage_table_entities_remove.row_key\n  returning session_storage_table_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "web_server"
        },
        "session_storage_table_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select session_storage_table_entities.partition_key, session_storage_table_entities.row_key, session_storage_table_entities.value, session_storage_table_entities.version, session_storage_table_entities.etag from session_storage_table_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if session_storage_table_entities_scan.pk is not null or session_storage_table_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if session_storage_table_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(session_storage_table_entities_scan.pk);\n  end if;\n\n  if session_storage_table_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(session_storage_table_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by session_storage_table_entities.partition_key, session_storage_table_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "taskcluster_check_runs_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into taskcluster_check_runs_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, taskcluster_check_runs_entities_create.version, new_etag)\n    where taskcluster_check_runs_entities.partition_key = taskcluster_check_runs_entities_create.pk and taskcluster_check_runs_entities.row_key = taskcluster_check_runs_entities_create.rk;\n  else\n    insert into taskcluster_check_runs_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "github"
        },
        "taskcluster_check_runs_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select taskcluster_check_runs_entities.partition_key, taskcluster_check_runs_entities.row_key, taskcluster_check_runs_entities.value, taskcluster_check_runs_entities.version,\n  taskcluster_check_runs_entities.etag from taskcluster_check_runs_entities\n  where taskcluster_check_runs_entities.partition_key = taskcluster_check_runs_entities_load.partition_key and taskcluster_check_runs_entities.row_key = taskcluster_check_runs_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_check_runs_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update taskcluster_check_runs_entities\n  set (value, version, etag) = (properties, taskcluster_check_runs_entities_modify.version, new_etag)\n  where taskcluster_check_runs_entities.partition_key = taskcluster_check_runs_entities_modify.partition_key and taskcluster_check_runs_entities.row_key = taskcluster_check_runs_entities_modify.row_key and taskcluster_check_runs_entities.etag = taskcluster_check_runs_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform taskcluster_check_runs_entities.etag from taskcluster_check_runs_entities\n  where taskcluster_check_runs_entities.partition_key = taskcluster_check_runs_entities_modify.partition_key and taskcluster_check_runs_entities.row_key = taskcluster_check_runs_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_check_runs_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from taskcluster_check_runs_entities\n  where taskcluster_check_runs_entities.partition_key = taskcluster_check_runs_entities_remove.partition_key and taskcluster_check_runs_entities.row_key = taskcluster_check_runs_entities_remove.row_key\n  returning taskcluster_check_runs_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_check_runs_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select taskcluster_check_runs_entities.partition_key, taskcluster_check_runs_entities.row_key, taskcluster_check_runs_entities.value, taskcluster_check_runs_entities.version, taskcluster_check_runs_entities.etag from taskcluster_check_runs_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if taskcluster_check_runs_entities_scan.pk is not null or taskcluster_check_runs_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if taskcluster_check_runs_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(taskcluster_check_runs_entities_scan.pk);\n  end if;\n\n  if taskcluster_check_runs_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(taskcluster_check_runs_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by taskcluster_check_runs_entities.partition_key, taskcluster_check_runs_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_checks_to_tasks_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into taskcluster_checks_to_tasks_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, taskcluster_checks_to_tasks_entities_create.version, new_etag)\n    where taskcluster_checks_to_tasks_entities.partition_key = taskcluster_checks_to_tasks_entities_create.pk and taskcluster_checks_to_tasks_entities.row_key = taskcluster_checks_to_tasks_entities_create.rk;\n  else\n    insert into taskcluster_checks_to_tasks_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "github"
        },
        "taskcluster_checks_to_tasks_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select taskcluster_checks_to_tasks_entities.partition_key, taskcluster_checks_to_tasks_entities.row_key, taskcluster_checks_to_tasks_entities.value, taskcluster_checks_to_tasks_entities.version,\n  taskcluster_checks_to_tasks_entities.etag from taskcluster_checks_to_tasks_entities\n  where taskcluster_checks_to_tasks_entities.partition_key = taskcluster_checks_to_tasks_entities_load.partition_key and taskcluster_checks_to_tasks_entities.row_key = taskcluster_checks_to_tasks_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_checks_to_tasks_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update taskcluster_checks_to_tasks_entities\n  set (value, version, etag) = (properties, taskcluster_checks_to_tasks_entities_modify.version, new_etag)\n  where taskcluster_checks_to_tasks_entities.partition_key = taskcluster_checks_to_tasks_entities_modify.partition_key and taskcluster_checks_to_tasks_entities.row_key = taskcluster_checks_to_tasks_entities_modify.row_key and taskcluster_checks_to_tasks_entities.etag = taskcluster_checks_to_tasks_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform taskcluster_checks_to_tasks_entities.etag from taskcluster_checks_to_tasks_entities\n  where taskcluster_checks_to_tasks_entities.partition_key = taskcluster_checks_to_tasks_entities_modify.partition_key and taskcluster_checks_to_tasks_entities.row_key = taskcluster_checks_to_tasks_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_checks_to_tasks_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from taskcluster_checks_to_tasks_entities\n  where taskcluster_checks_to_tasks_entities.partition_key = taskcluster_checks_to_tasks_entities_remove.partition_key and taskcluster_checks_to_tasks_entities.row_key = taskcluster_checks_to_tasks_entities_remove.row_key\n  returning taskcluster_checks_to_tasks_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_checks_to_tasks_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select taskcluster_checks_to_tasks_entities.partition_key, taskcluster_checks_to_tasks_entities.row_key, taskcluster_checks_to_tasks_entities.value, taskcluster_checks_to_tasks_entities.version, taskcluster_checks_to_tasks_entities.etag from taskcluster_checks_to_tasks_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if taskcluster_checks_to_tasks_entities_scan.pk is not null or taskcluster_checks_to_tasks_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if taskcluster_checks_to_tasks_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(taskcluster_checks_to_tasks_entities_scan.pk);\n  end if;\n\n  if taskcluster_checks_to_tasks_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(taskcluster_checks_to_tasks_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by taskcluster_checks_to_tasks_entities.partition_key, taskcluster_checks_to_tasks_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_github_builds_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into taskcluster_github_builds_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, taskcluster_github_builds_entities_create.version, new_etag)\n    where taskcluster_github_builds_entities.partition_key = taskcluster_github_builds_entities_create.pk and taskcluster_github_builds_entities.row_key = taskcluster_github_builds_entities_create.rk;\n  else\n    insert into taskcluster_github_builds_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "github"
        },
        "taskcluster_github_builds_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select taskcluster_github_builds_entities.partition_key, taskcluster_github_builds_entities.row_key, taskcluster_github_builds_entities.value, taskcluster_github_builds_entities.version,\n  taskcluster_github_builds_entities.etag from taskcluster_github_builds_entities\n  where taskcluster_github_builds_entities.partition_key = taskcluster_github_builds_entities_load.partition_key and taskcluster_github_builds_entities.row_key = taskcluster_github_builds_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_github_builds_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update taskcluster_github_builds_entities\n  set (value, version, etag) = (properties, taskcluster_github_builds_entities_modify.version, new_etag)\n  where taskcluster_github_builds_entities.partition_key = taskcluster_github_builds_entities_modify.partition_key and taskcluster_github_builds_entities.row_key = taskcluster_github_builds_entities_modify.row_key and taskcluster_github_builds_entities.etag = taskcluster_github_builds_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform taskcluster_github_builds_entities.etag from taskcluster_github_builds_entities\n  where taskcluster_github_builds_entities.partition_key = taskcluster_github_builds_entities_modify.partition_key and taskcluster_github_builds_entities.row_key = taskcluster_github_builds_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_github_builds_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from taskcluster_github_builds_entities\n  where taskcluster_github_builds_entities.partition_key = taskcluster_github_builds_entities_remove.partition_key and taskcluster_github_builds_entities.row_key = taskcluster_github_builds_entities_remove.row_key\n  returning taskcluster_github_builds_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_github_builds_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select taskcluster_github_builds_entities.partition_key, taskcluster_github_builds_entities.row_key, taskcluster_github_builds_entities.value, taskcluster_github_builds_entities.version, taskcluster_github_builds_entities.etag from taskcluster_github_builds_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if taskcluster_github_builds_entities_scan.pk is not null or taskcluster_github_builds_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if taskcluster_github_builds_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(taskcluster_github_builds_entities_scan.pk);\n  end if;\n\n  if taskcluster_github_builds_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(taskcluster_github_builds_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by taskcluster_github_builds_entities.partition_key, taskcluster_github_builds_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_integration_owners_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into taskcluster_integration_owners_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, taskcluster_integration_owners_entities_create.version, new_etag)\n    where taskcluster_integration_owners_entities.partition_key = taskcluster_integration_owners_entities_create.pk and taskcluster_integration_owners_entities.row_key = taskcluster_integration_owners_entities_create.rk;\n  else\n    insert into taskcluster_integration_owners_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "github"
        },
        "taskcluster_integration_owners_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select taskcluster_integration_owners_entities.partition_key, taskcluster_integration_owners_entities.row_key, taskcluster_integration_owners_entities.value, taskcluster_integration_owners_entities.version,\n  taskcluster_integration_owners_entities.etag from taskcluster_integration_owners_entities\n  where taskcluster_integration_owners_entities.partition_key = taskcluster_integration_owners_entities_load.partition_key and taskcluster_integration_owners_entities.row_key = taskcluster_integration_owners_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_integration_owners_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update taskcluster_integration_owners_entities\n  set (value, version, etag) = (properties, taskcluster_integration_owners_entities_modify.version, new_etag)\n  where taskcluster_integration_owners_entities.partition_key = taskcluster_integration_owners_entities_modify.partition_key and taskcluster_integration_owners_entities.row_key = taskcluster_integration_owners_entities_modify.row_key and taskcluster_integration_owners_entities.etag = taskcluster_integration_owners_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform taskcluster_integration_owners_entities.etag from taskcluster_integration_owners_entities\n  where taskcluster_integration_owners_entities.partition_key = taskcluster_integration_owners_entities_modify.partition_key and taskcluster_integration_owners_entities.row_key = taskcluster_integration_owners_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_integration_owners_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from taskcluster_integration_owners_entities\n  where taskcluster_integration_owners_entities.partition_key = taskcluster_integration_owners_entities_remove.partition_key and taskcluster_integration_owners_entities.row_key = taskcluster_integration_owners_entities_remove.row_key\n  returning taskcluster_integration_owners_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_integration_owners_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select taskcluster_integration_owners_entities.partition_key, taskcluster_integration_owners_entities.row_key, taskcluster_integration_owners_entities.value, taskcluster_integration_owners_entities.version, taskcluster_integration_owners_entities.etag from taskcluster_integration_owners_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if taskcluster_integration_owners_entities_scan.pk is not null or taskcluster_integration_owners_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if taskcluster_integration_owners_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(taskcluster_integration_owners_entities_scan.pk);\n  end if;\n\n  if taskcluster_integration_owners_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(taskcluster_integration_owners_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by taskcluster_integration_owners_entities.partition_key, taskcluster_integration_owners_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "wmworker_pool_errors_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into wmworker_pool_errors_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, wmworker_pool_errors_entities_create.version, new_etag)\n    where wmworker_pool_errors_entities.partition_key = wmworker_pool_errors_entities_create.pk and wmworker_pool_errors_entities.row_key = wmworker_pool_errors_entities_create.rk;\n  else\n    insert into wmworker_pool_errors_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "worker_manager"
        },
        "wmworker_pool_errors_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select wmworker_pool_errors_entities.partition_key, wmworker_pool_errors_entities.row_key, wmworker_pool_errors_entities.value, wmworker_pool_errors_entities.version,\n  wmworker_pool_errors_entities.etag from wmworker_pool_errors_entities\n  where wmworker_pool_errors_entities.partition_key = wmworker_pool_errors_entities_load.partition_key and wmworker_pool_errors_entities.row_key = wmworker_pool_errors_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pool_errors_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update wmworker_pool_errors_entities\n  set (value, version, etag) = (properties, wmworker_pool_errors_entities_modify.version, new_etag)\n  where wmworker_pool_errors_entities.partition_key = wmworker_pool_errors_entities_modify.partition_key and wmworker_pool_errors_entities.row_key = wmworker_pool_errors_entities_modify.row_key and wmworker_pool_errors_entities.etag = wmworker_pool_errors_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform wmworker_pool_errors_entities.etag from wmworker_pool_errors_entities\n  where wmworker_pool_errors_entities.partition_key = wmworker_pool_errors_entities_modify.partition_key and wmworker_pool_errors_entities.row_key = wmworker_pool_errors_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pool_errors_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from wmworker_pool_errors_entities\n  where wmworker_pool_errors_entities.partition_key = wmworker_pool_errors_entities_remove.partition_key and wmworker_pool_errors_entities.row_key = wmworker_pool_errors_entities_remove.row_key\n  returning wmworker_pool_errors_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pool_errors_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select wmworker_pool_errors_entities.partition_key, wmworker_pool_errors_entities.row_key, wmworker_pool_errors_entities.value, wmworker_pool_errors_entities.version, wmworker_pool_errors_entities.etag from wmworker_pool_errors_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if wmworker_pool_errors_entities_scan.pk is not null or wmworker_pool_errors_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if wmworker_pool_errors_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(wmworker_pool_errors_entities_scan.pk);\n  end if;\n\n  if wmworker_pool_errors_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(wmworker_pool_errors_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by wmworker_pool_errors_entities.partition_key, wmworker_pool_errors_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pools_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into wmworker_pools_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, wmworker_pools_entities_create.version, new_etag)\n    where wmworker_pools_entities.partition_key = wmworker_pools_entities_create.pk and wmworker_pools_entities.row_key = wmworker_pools_entities_create.rk;\n  else\n    insert into wmworker_pools_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "worker_manager"
        },
        "wmworker_pools_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select wmworker_pools_entities.partition_key, wmworker_pools_entities.row_key, wmworker_pools_entities.value, wmworker_pools_entities.version,\n  wmworker_pools_entities.etag from wmworker_pools_entities\n  where wmworker_pools_entities.partition_key = wmworker_pools_entities_load.partition_key and wmworker_pools_entities.row_key = wmworker_pools_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pools_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update wmworker_pools_entities\n  set (value, version, etag) = (properties, wmworker_pools_entities_modify.version, new_etag)\n  where wmworker_pools_entities.partition_key = wmworker_pools_entities_modify.partition_key and wmworker_pools_entities.row_key = wmworker_pools_entities_modify.row_key and wmworker_pools_entities.etag = wmworker_pools_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform wmworker_pools_entities.etag from wmworker_pools_entities\n  where wmworker_pools_entities.partition_key = wmworker_pools_entities_modify.partition_key and wmworker_pools_entities.row_key = wmworker_pools_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pools_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from wmworker_pools_entities\n  where wmworker_pools_entities.partition_key = wmworker_pools_entities_remove.partition_key and wmworker_pools_entities.row_key = wmworker_pools_entities_remove.row_key\n  returning wmworker_pools_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pools_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select wmworker_pools_entities.partition_key, wmworker_pools_entities.row_key, wmworker_pools_entities.value, wmworker_pools_entities.version, wmworker_pools_entities.etag from wmworker_pools_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if wmworker_pools_entities_scan.pk is not null or wmworker_pools_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if wmworker_pools_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(wmworker_pools_entities_scan.pk);\n  end if;\n\n  if wmworker_pools_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(wmworker_pools_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by wmworker_pools_entities.partition_key, wmworker_pools_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworkers_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into wmworkers_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, wmworkers_entities_create.version, new_etag)\n    where wmworkers_entities.partition_key = wmworkers_entities_create.pk and wmworkers_entities.row_key = wmworkers_entities_create.rk;\n  else\n    insert into wmworkers_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "worker_manager"
        },
        "wmworkers_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select wmworkers_entities.partition_key, wmworkers_entities.row_key, wmworkers_entities.value, wmworkers_entities.version,\n  wmworkers_entities.etag from wmworkers_entities\n  where wmworkers_entities.partition_key = wmworkers_entities_load.partition_key and wmworkers_entities.row_key = wmworkers_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworkers_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update wmworkers_entities\n  set (value, version, etag) = (properties, wmworkers_entities_modify.version, new_etag)\n  where wmworkers_entities.partition_key = wmworkers_entities_modify.partition_key and wmworkers_entities.row_key = wmworkers_entities_modify.row_key and wmworkers_entities.etag = wmworkers_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform wmworkers_entities.etag from wmworkers_entities\n  where wmworkers_entities.partition_key = wmworkers_entities_modify.partition_key and wmworkers_entities.row_key = wmworkers_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworkers_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from wmworkers_entities\n  where wmworkers_entities.partition_key = wmworkers_entities_remove.partition_key and wmworkers_entities.row_key = wmworkers_entities_remove.row_key\n  returning wmworkers_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworkers_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select wmworkers_entities.partition_key, wmworkers_entities.row_key, wmworkers_entities.value, wmworkers_entities.version, wmworkers_entities.etag from wmworkers_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if wmworkers_entities_scan.pk is not null or wmworkers_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if wmworkers_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(wmworkers_entities_scan.pk);\n  end if;\n\n  if wmworkers_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(wmworkers_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by wmworkers_entities.partition_key, wmworkers_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        }
      },
      "migrationScript": "begin\n  create table clients_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table clients_entities add primary key (partition_key, row_key);\n\n  create table roles_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table roles_entities add primary key (partition_key, row_key);\n\n  create table taskcluster_github_builds_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table taskcluster_github_builds_entities add primary key (partition_key, row_key);\n\n  create table taskcluster_integration_owners_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table taskcluster_integration_owners_entities add primary key (partition_key, row_key);\n\n  create table taskcluster_checks_to_tasks_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table taskcluster_checks_to_tasks_entities add primary key (partition_key, row_key);\n\n  create table taskcluster_check_runs_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table taskcluster_check_runs_entities add primary key (partition_key, row_key);\n\n  create table hooks_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table hooks_entities add primary key (partition_key, row_key);\n\n  create table queues_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queues_entities add primary key (partition_key, row_key);\n\n  create table last_fire_3_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table last_fire_3_entities add primary key (partition_key, row_key);\n\n  create table indexed_tasks_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table indexed_tasks_entities add primary key (partition_key, row_key);\n\n  create table namespaces_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table namespaces_entities add primary key (partition_key, row_key);\n\n  create table denylisted_notification_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table denylisted_notification_entities add primary key (partition_key, row_key);\n\n  create table cache_purges_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table cache_purges_entities add primary key (partition_key, row_key);\n\n  create table queue_tasks_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_tasks_entities add primary key (partition_key, row_key);\n\n  create table queue_artifacts_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_artifacts_entities add primary key (partition_key, row_key);\n\n  create table queue_task_groups_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_task_groups_entities add primary key (partition_key, row_key);\n\n  create table queue_task_group_members_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_task_group_members_entities add primary key (partition_key, row_key);\n\n  create table queue_task_group_active_sets_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_task_group_active_sets_entities add primary key (partition_key, row_key);\n\n  create table queue_task_requirement_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_task_requirement_entities add primary key (partition_key, row_key);\n\n  create table queue_task_dependency_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_task_dependency_entities add primary key (partition_key, row_key);\n\n  create table queue_worker_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_worker_entities add primary key (partition_key, row_key);\n\n  create table queue_worker_type_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_worker_type_entities add primary key (partition_key, row_key);\n\n  create table queue_provisioner_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_provisioner_entities add primary key (partition_key, row_key);\n\n  create table secrets_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table secrets_entities add primary key (partition_key, row_key);\n\n  create table authorization_codes_table_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table authorization_codes_table_entities add primary key (partition_key, row_key);\n\n  create table access_token_table_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table access_token_table_entities add primary key (partition_key, row_key);\n\n  create table session_storage_table_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table session_storage_table_entities add primary key (partition_key, row_key);\n\n  create table github_access_token_table_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table github_access_token_table_entities add primary key (partition_key, row_key);\n\n  create table wmworkers_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table wmworkers_entities add primary key (partition_key, row_key);\n\n  create table wmworker_pools_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table wmworker_pools_entities add primary key (partition_key, row_key);\n\n  create table wmworker_pool_errors_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table wmworker_pool_errors_entities add primary key (partition_key, row_key);\n\n  grant select, insert, update, delete on clients_entities to $db_user_prefix$_auth;\n  grant select, insert, update, delete on roles_entities to $db_user_prefix$_auth;\n\n  grant select, insert, update, delete on taskcluster_check_runs_entities to $db_user_prefix$_github;\n  grant select, insert, update, delete on taskcluster_checks_to_tasks_entities to $db_user_prefix$_github;\n  grant select, insert, update, delete on taskcluster_github_builds_entities to $db_user_prefix$_github;\n  grant select, insert, update, delete on taskcluster_integration_owners_entities to $db_user_prefix$_github;\n\n  grant select, insert, update, delete on hooks_entities to $db_user_prefix$_hooks;\n  grant select, insert, update, delete on last_fire_3_entities to $db_user_prefix$_hooks;\n  grant select, insert, update, delete on queues_entities to $db_user_prefix$_hooks;\n\n  grant select, insert, update, delete on indexed_tasks_entities to $db_user_prefix$_index;\n  grant select, insert, update, delete on namespaces_entities to $db_user_prefix$_index;\n\n  grant select, insert, update, delete on denylisted_notification_entities to $db_user_prefix$_notify;\n\n  grant select, insert, update, delete on cache_purges_entities to $db_user_prefix$_purge_cache;\n\n  grant select, insert, update, delete on secrets_entities to $db_user_prefix$_secrets;\n\n  grant select, insert, update, delete on access_token_table_entities to $db_user_prefix$_web_server;\n  grant select, insert, update, delete on authorization_codes_table_entities to $db_user_prefix$_web_server;\n  grant select, insert, update, delete on github_access_token_table_entities to $db_user_prefix$_web_server;\n  grant select, insert, update, delete on session_storage_table_entities to $db_user_prefix$_web_server;\n\n  grant select, insert, update, delete on wmworker_pool_errors_entities to $db_user_prefix$_worker_manager;\n  grant select, insert, update, delete on wmworker_pools_entities to $db_user_prefix$_worker_manager;\n  grant select, insert, update, delete on wmworkers_entities to $db_user_prefix$_worker_manager;\n\n  grant select, insert, update, delete on queue_tasks_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_artifacts_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_task_groups_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_task_group_members_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_task_group_active_sets_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_task_requirement_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_task_dependency_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_worker_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_worker_type_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_provisioner_entities to $db_user_prefix$_queue;\nend",
      "version": 2
    },
    {
      "downgradeScript": "begin\n  revoke select, insert, update, delete on azure_queue_messages from $db_user_prefix$_queue;\n  drop table azure_queue_messages;\nend",
      "methods": {
        "azure_queue_count": {
          "args": "queue_name text",
          "body": "begin\n  return (select count(*)\n  from azure_queue_messages msgs\n  where msgs.queue_name = azure_queue_count.queue_name);\nend",
          "deprecated": false,
          "description": "Count messages in the named queue.\n",
          "mode": "read",
          "returns": "integer",
          "serviceName": "queue"
        },
        "azure_queue_delete": {
          "args": "queue_name text, message_id uuid, pop_receipt uuid",
          "body": "begin\n  delete from azure_queue_messages msgs\n    where msgs.queue_name = azure_queue_delete.queue_name\n      and msgs.message_id = azure_queue_delete.message_id\n      and msgs.pop_receipt = azure_queue_delete.pop_receipt;\nend",
          "deprecated": false,
          "description": "Delete the message identified by the given `queue_name`, `message_id` and\n`pop_receipt`.\n",
          "mode": "write",
          "returns": "void",
          "serviceName": "queue"
        },
        "azure_queue_delete_expired": {
          "args": "",
          "body": "begin\n  delete from azure_queue_messages msgs\n    where msgs.expires <= now();\nend",
          "deprecated": false,
          "description": "Delete all expired messages.  This is a maintenance task that should occur\nabout once an hour.\n",
          "mode": "write",
          "returns": "void",
          "serviceName": "queue"
        },
        "azure_queue_get": {
          "args": "queue_name text, visible timestamp, count integer",
          "body": "begin\n  return query update azure_queue_messages m1\n    set\n      pop_receipt = public.gen_random_uuid(),\n      visible = azure_queue_get.visible\n    where\n      m1.message_id in (\n        select m2.message_id from azure_queue_messages m2\n        where m2.queue_name = azure_queue_get.queue_name\n          and m2.visible <= now()\n          and m2.expires > now()\n        order by m2.inserted\n        for update skip locked\n        limit count\n    )\n    returning m1.message_id, m1.message_text, m1.pop_receipt;\nend",
          "deprecated": false,
          "description": "Get up to `count` messages from the given queue, setting the `visible`\ncolumn of each to the given value.  Returns a `message_id` and\n`pop_receipt` for each one, for use with `azure_queue_delete` and\n`azure_queue_update`.\n",
          "mode": "write",
          "returns": "table (message_id uuid, message_text text, pop_receipt uuid)",
          "serviceName": "queue"
        },
        "azure_queue_put": {
          "args": "queue_name text, message_text text, visible timestamp, expires timestamp",
          "body": "begin\n  insert into azure_queue_messages (\n      queue_name,\n      message_id,\n      message_text,\n      inserted,\n      visible,\n      expires\n    ) values (\n      azure_queue_put.queue_name,\n      public.gen_random_uuid(),\n      azure_queue_put.message_text,\n      now(),\n      azure_queue_put.visible,\n      azure_queue_put.expires\n    );\n  execute 'notify ' || quote_ident(queue_name);\nend",
          "deprecated": false,
          "description": "Put the given message into the given queue.  The message will not be visible until\nafter the visible timestamp, and will disappear after the expires timestamp.\n",
          "mode": "write",
          "returns": "void",
          "serviceName": "queue"
        },
        "azure_queue_update": {
          "args": "queue_name text, message_text text, message_id uuid, pop_receipt uuid, visible timestamp",
          "body": "begin\n  update azure_queue_messages msgs\n    set message_text = azure_queue_update.message_text,\n      visible = azure_queue_update.visible\n    where msgs.queue_name = azure_queue_update.queue_name\n      and msgs.message_id = azure_queue_update.message_id\n      and msgs.pop_receipt = azure_queue_update.pop_receipt;\nend",
          "deprecated": false,
          "description": "Update the message identified by the given `queue_name`, `message_id` and\n`pop_receipt`, setting its `visible` and `message_text` properties as\ngiven.\n",
          "mode": "write",
          "returns": "void",
          "serviceName": "queue"
        }
      },
      "migrationScript": "begin\n  create table azure_queue_messages (\n    message_id uuid not null primary key,\n    queue_name text not null,\n    message_text text not null,\n    inserted timestamp not null,\n    visible timestamp not null, -- visible after this time\n    expires timestamp not null,  -- expired after this time\n    pop_receipt uuid -- null means not popped\n  );\n  -- 'get' operations sort by inserted within a queue\n  create index azure_queue_messages_inserted on azure_queue_messages(queue_name, inserted);\n  grant select, insert, update, delete on azure_queue_messages to $db_user_prefix$_queue;\nend",
      "version": 3
    },
    {
      "downgradeScript": "begin\n  alter table azure_queue_messages\n    alter column inserted type timestamp,\n    alter column visible type timestamp,\n    alter column expires type timestamp;\nend",
      "methods": {
      },
      "migrationScript": "begin\n  alter table azure_queue_messages\n    alter column inserted type timestamptz,\n    alter column visible type timestamptz,\n    alter column expires type timestamptz;\nend",
      "version": 4
    },
    {
      "methods": {
        "azure_queue_get": {
          "args": "queue_name text, visible timestamp, count integer",
          "body": "begin\n  return query\n    with updated as (\n      update azure_queue_messages m\n      set\n        pop_receipt = public.gen_random_uuid(),\n        visible = azure_queue_get.visible\n      where\n        m.message_id in (\n          select m2.message_id from azure_queue_messages m2\n          where m2.queue_name = azure_queue_get.queue_name\n            and m2.visible <= now()\n            and m2.expires > now()\n          order by m2.inserted\n          for update skip locked\n          limit count\n      )\n      returning m.inserted, m.message_id, m.message_text, m.pop_receipt\n    )\n    select\n      u.message_id, u.message_text, u.pop_receipt\n    from updated as u\n    order by u.inserted;\nend",
          "deprecated": false,
          "description": "Get up to `count` messages from the given queue, setting the `visible`\ncolumn of each to the given value.  Returns a `message_id` and\n`pop_receipt` for each one, for use with `azure_queue_delete` and\n`azure_queue_update`.\n",
          "mode": "write",
          "returns": "table (message_id uuid, message_text text, pop_receipt uuid)",
          "serviceName": "queue"
        }
      },
      "version": 5
    },
    {
      "methods": {
        "azure_queue_count": {
          "args": "queue_name text",
          "body": "begin\n  return (\n    select\n      count(*)\n    from\n      azure_queue_messages msgs\n    where\n      msgs.queue_name = azure_queue_count.queue_name\n      and msgs.expires > now()\n  );\nend",
          "deprecated": false,
          "description": "Count non-expired messages in the named queue.\n",
          "mode": "read",
          "returns": "integer",
          "serviceName": "queue"
        }
      },
      "version": 6
    },
    {
      "methods": {
        "access_token_table_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select access_token_table_entities.partition_key, access_token_table_entities.row_key, access_token_table_entities.value, access_token_table_entities.version, access_token_table_entities.etag from access_token_table_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if access_token_table_entities_scan.pk is not null or access_token_table_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if access_token_table_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(access_token_table_entities_scan.pk);\n  end if;\n\n  if access_token_table_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(access_token_table_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by access_token_table_entities.partition_key, access_token_table_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "authorization_codes_table_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select authorization_codes_table_entities.partition_key, authorization_codes_table_entities.row_key, authorization_codes_table_entities.value, authorization_codes_table_entities.version, authorization_codes_table_entities.etag from authorization_codes_table_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if authorization_codes_table_entities_scan.pk is not null or authorization_codes_table_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if authorization_codes_table_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(authorization_codes_table_entities_scan.pk);\n  end if;\n\n  if authorization_codes_table_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(authorization_codes_table_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by authorization_codes_table_entities.partition_key, authorization_codes_table_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "cache_purges_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select cache_purges_entities.partition_key, cache_purges_entities.row_key, cache_purges_entities.value, cache_purges_entities.version, cache_purges_entities.etag from cache_purges_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if cache_purges_entities_scan.pk is not null or cache_purges_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if cache_purges_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(cache_purges_entities_scan.pk);\n  end if;\n\n  if cache_purges_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(cache_purges_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by cache_purges_entities.partition_key, cache_purges_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "purge_cache"
        },
        "clients_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select clients_entities.partition_key, clients_entities.row_key, clients_entities.value, clients_entities.version, clients_entities.etag from clients_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if clients_entities_scan.pk is not null or clients_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if clients_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(clients_entities_scan.pk);\n  end if;\n\n  if clients_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(clients_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by clients_entities.partition_key, clients_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "auth"
        },
        "denylisted_notification_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select denylisted_notification_entities.partition_key, denylisted_notification_entities.row_key, denylisted_notification_entities.value, denylisted_notification_entities.version, denylisted_notification_entities.etag from denylisted_notification_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if denylisted_notification_entities_scan.pk is not null or denylisted_notification_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if denylisted_notification_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(denylisted_notification_entities_scan.pk);\n  end if;\n\n  if denylisted_notification_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(denylisted_notification_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by denylisted_notification_entities.partition_key, denylisted_notification_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "notify"
        },
        "github_access_token_table_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select github_access_token_table_entities.partition_key, github_access_token_table_entities.row_key, github_access_token_table_entities.value, github_access_token_table_entities.version, github_access_token_table_entities.etag from github_access_token_table_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if github_access_token_table_entities_scan.pk is not null or github_access_token_table_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if github_access_token_table_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(github_access_token_table_entities_scan.pk);\n  end if;\n\n  if github_access_token_table_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(github_access_token_table_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by github_access_token_table_entities.partition_key, github_access_token_table_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "hooks_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select hooks_entities.partition_key, hooks_entities.row_key, hooks_entities.value, hooks_entities.version, hooks_entities.etag from hooks_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if hooks_entities_scan.pk is not null or hooks_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if hooks_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(hooks_entities_scan.pk);\n  end if;\n\n  if hooks_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(hooks_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by hooks_entities.partition_key, hooks_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "indexed_tasks_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select indexed_tasks_entities.partition_key, indexed_tasks_entities.row_key, indexed_tasks_entities.value, indexed_tasks_entities.version, indexed_tasks_entities.etag from indexed_tasks_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if indexed_tasks_entities_scan.pk is not null or indexed_tasks_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if indexed_tasks_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(indexed_tasks_entities_scan.pk);\n  end if;\n\n  if indexed_tasks_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(indexed_tasks_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by indexed_tasks_entities.partition_key, indexed_tasks_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "index"
        },
        "last_fire_3_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select last_fire_3_entities.partition_key, last_fire_3_entities.row_key, last_fire_3_entities.value, last_fire_3_entities.version, last_fire_3_entities.etag from last_fire_3_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if last_fire_3_entities_scan.pk is not null or last_fire_3_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if last_fire_3_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(last_fire_3_entities_scan.pk);\n  end if;\n\n  if last_fire_3_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(last_fire_3_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by last_fire_3_entities.partition_key, last_fire_3_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "namespaces_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select namespaces_entities.partition_key, namespaces_entities.row_key, namespaces_entities.value, namespaces_entities.version, namespaces_entities.etag from namespaces_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if namespaces_entities_scan.pk is not null or namespaces_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if namespaces_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(namespaces_entities_scan.pk);\n  end if;\n\n  if namespaces_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(namespaces_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by namespaces_entities.partition_key, namespaces_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "index"
        },
        "queue_artifacts_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_artifacts_entities.partition_key, queue_artifacts_entities.row_key, queue_artifacts_entities.value, queue_artifacts_entities.version, queue_artifacts_entities.etag from queue_artifacts_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_artifacts_entities_scan.pk is not null or queue_artifacts_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_artifacts_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_artifacts_entities_scan.pk);\n  end if;\n\n  if queue_artifacts_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_artifacts_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_artifacts_entities.partition_key, queue_artifacts_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_provisioner_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_provisioner_entities.partition_key, queue_provisioner_entities.row_key, queue_provisioner_entities.value, queue_provisioner_entities.version, queue_provisioner_entities.etag from queue_provisioner_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_provisioner_entities_scan.pk is not null or queue_provisioner_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_provisioner_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_provisioner_entities_scan.pk);\n  end if;\n\n  if queue_provisioner_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_provisioner_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_provisioner_entities.partition_key, queue_provisioner_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_dependency_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_dependency_entities.partition_key, queue_task_dependency_entities.row_key, queue_task_dependency_entities.value, queue_task_dependency_entities.version, queue_task_dependency_entities.etag from queue_task_dependency_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_task_dependency_entities_scan.pk is not null or queue_task_dependency_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_dependency_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_dependency_entities_scan.pk);\n  end if;\n\n  if queue_task_dependency_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_dependency_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_dependency_entities.partition_key, queue_task_dependency_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_active_sets_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_group_active_sets_entities.partition_key, queue_task_group_active_sets_entities.row_key, queue_task_group_active_sets_entities.value, queue_task_group_active_sets_entities.version, queue_task_group_active_sets_entities.etag from queue_task_group_active_sets_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_task_group_active_sets_entities_scan.pk is not null or queue_task_group_active_sets_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_group_active_sets_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_group_active_sets_entities_scan.pk);\n  end if;\n\n  if queue_task_group_active_sets_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_group_active_sets_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_group_active_sets_entities.partition_key, queue_task_group_active_sets_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_members_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_group_members_entities.partition_key, queue_task_group_members_entities.row_key, queue_task_group_members_entities.value, queue_task_group_members_entities.version, queue_task_group_members_entities.etag from queue_task_group_members_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_task_group_members_entities_scan.pk is not null or queue_task_group_members_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_group_members_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_group_members_entities_scan.pk);\n  end if;\n\n  if queue_task_group_members_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_group_members_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_group_members_entities.partition_key, queue_task_group_members_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_groups_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_groups_entities.partition_key, queue_task_groups_entities.row_key, queue_task_groups_entities.value, queue_task_groups_entities.version, queue_task_groups_entities.etag from queue_task_groups_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_task_groups_entities_scan.pk is not null or queue_task_groups_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_groups_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_groups_entities_scan.pk);\n  end if;\n\n  if queue_task_groups_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_groups_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_groups_entities.partition_key, queue_task_groups_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_requirement_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_requirement_entities.partition_key, queue_task_requirement_entities.row_key, queue_task_requirement_entities.value, queue_task_requirement_entities.version, queue_task_requirement_entities.etag from queue_task_requirement_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_task_requirement_entities_scan.pk is not null or queue_task_requirement_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_requirement_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_requirement_entities_scan.pk);\n  end if;\n\n  if queue_task_requirement_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_requirement_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_requirement_entities.partition_key, queue_task_requirement_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_tasks_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_tasks_entities.partition_key, queue_tasks_entities.row_key, queue_tasks_entities.value, queue_tasks_entities.version, queue_tasks_entities.etag from queue_tasks_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_tasks_entities_scan.pk is not null or queue_tasks_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_tasks_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_tasks_entities_scan.pk);\n  end if;\n\n  if queue_tasks_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_tasks_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_tasks_entities.partition_key, queue_tasks_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_worker_entities.partition_key, queue_worker_entities.row_key, queue_worker_entities.value, queue_worker_entities.version, queue_worker_entities.etag from queue_worker_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_worker_entities_scan.pk is not null or queue_worker_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_worker_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_worker_entities_scan.pk);\n  end if;\n\n  if queue_worker_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_worker_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_worker_entities.partition_key, queue_worker_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_type_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_worker_type_entities.partition_key, queue_worker_type_entities.row_key, queue_worker_type_entities.value, queue_worker_type_entities.version, queue_worker_type_entities.etag from queue_worker_type_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_worker_type_entities_scan.pk is not null or queue_worker_type_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_worker_type_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_worker_type_entities_scan.pk);\n  end if;\n\n  if queue_worker_type_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_worker_type_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_worker_type_entities.partition_key, queue_worker_type_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queues_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queues_entities.partition_key, queues_entities.row_key, queues_entities.value, queues_entities.version, queues_entities.etag from queues_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queues_entities_scan.pk is not null or queues_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queues_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queues_entities_scan.pk);\n  end if;\n\n  if queues_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queues_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queues_entities.partition_key, queues_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "roles_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select roles_entities.partition_key, roles_entities.row_key, roles_entities.value, roles_entities.version, roles_entities.etag from roles_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if roles_entities_scan.pk is not null or roles_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if roles_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(roles_entities_scan.pk);\n  end if;\n\n  if roles_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(roles_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by roles_entities.partition_key, roles_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "auth"
        },
        "secrets_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select secrets_entities.partition_key, secrets_entities.row_key, secrets_entities.value, secrets_entities.version, secrets_entities.etag from secrets_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if secrets_entities_scan.pk is not null or secrets_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if secrets_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(secrets_entities_scan.pk);\n  end if;\n\n  if secrets_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(secrets_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by secrets_entities.partition_key, secrets_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "secrets"
        },
        "session_storage_table_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select session_storage_table_entities.partition_key, session_storage_table_entities.row_key, session_storage_table_entities.value, session_storage_table_entities.version, session_storage_table_entities.etag from session_storage_table_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if session_storage_table_entities_scan.pk is not null or session_storage_table_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if session_storage_table_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(session_storage_table_entities_scan.pk);\n  end if;\n\n  if session_storage_table_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(session_storage_table_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by session_storage_table_entities.partition_key, session_storage_table_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "taskcluster_check_runs_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select taskcluster_check_runs_entities.partition_key, taskcluster_check_runs_entities.row_key, taskcluster_check_runs_entities.value, taskcluster_check_runs_entities.version, taskcluster_check_runs_entities.etag from taskcluster_check_runs_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if taskcluster_check_runs_entities_scan.pk is not null or taskcluster_check_runs_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if taskcluster_check_runs_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(taskcluster_check_runs_entities_scan.pk);\n  end if;\n\n  if taskcluster_check_runs_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(taskcluster_check_runs_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by taskcluster_check_runs_entities.partition_key, taskcluster_check_runs_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_checks_to_tasks_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select taskcluster_checks_to_tasks_entities.partition_key, taskcluster_checks_to_tasks_entities.row_key, taskcluster_checks_to_tasks_entities.value, taskcluster_checks_to_tasks_entities.version, taskcluster_checks_to_tasks_entities.etag from taskcluster_checks_to_tasks_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if taskcluster_checks_to_tasks_entities_scan.pk is not null or taskcluster_checks_to_tasks_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if taskcluster_checks_to_tasks_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(taskcluster_checks_to_tasks_entities_scan.pk);\n  end if;\n\n  if taskcluster_checks_to_tasks_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(taskcluster_checks_to_tasks_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by taskcluster_checks_to_tasks_entities.partition_key, taskcluster_checks_to_tasks_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_github_builds_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select taskcluster_github_builds_entities.partition_key, taskcluster_github_builds_entities.row_key, taskcluster_github_builds_entities.value, taskcluster_github_builds_entities.version, taskcluster_github_builds_entities.etag from taskcluster_github_builds_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if taskcluster_github_builds_entities_scan.pk is not null or taskcluster_github_builds_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if taskcluster_github_builds_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(taskcluster_github_builds_entities_scan.pk);\n  end if;\n\n  if taskcluster_github_builds_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(taskcluster_github_builds_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by taskcluster_github_builds_entities.partition_key, taskcluster_github_builds_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_integration_owners_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select taskcluster_integration_owners_entities.partition_key, taskcluster_integration_owners_entities.row_key, taskcluster_integration_owners_entities.value, taskcluster_integration_owners_entities.version, taskcluster_integration_owners_entities.etag from taskcluster_integration_owners_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if taskcluster_integration_owners_entities_scan.pk is not null or taskcluster_integration_owners_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if taskcluster_integration_owners_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(taskcluster_integration_owners_entities_scan.pk);\n  end if;\n\n  if taskcluster_integration_owners_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(taskcluster_integration_owners_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by taskcluster_integration_owners_entities.partition_key, taskcluster_integration_owners_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "wmworker_pool_errors_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select wmworker_pool_errors_entities.partition_key, wmworker_pool_errors_entities.row_key, wmworker_pool_errors_entities.value, wmworker_pool_errors_entities.version, wmworker_pool_errors_entities.etag from wmworker_pool_errors_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if wmworker_pool_errors_entities_scan.pk is not null or wmworker_pool_errors_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if wmworker_pool_errors_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(wmworker_pool_errors_entities_scan.pk);\n  end if;\n\n  if wmworker_pool_errors_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(wmworker_pool_errors_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by wmworker_pool_errors_entities.partition_key, wmworker_pool_errors_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pools_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select wmworker_pools_entities.partition_key, wmworker_pools_entities.row_key, wmworker_pools_entities.value, wmworker_pools_entities.version, wmworker_pools_entities.etag from wmworker_pools_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if wmworker_pools_entities_scan.pk is not null or wmworker_pools_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if wmworker_pools_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(wmworker_pools_entities_scan.pk);\n  end if;\n\n  if wmworker_pools_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(wmworker_pools_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by wmworker_pools_entities.partition_key, wmworker_pools_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworkers_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select wmworkers_entities.partition_key, wmworkers_entities.row_key, wmworkers_entities.value, wmworkers_entities.version, wmworkers_entities.etag from wmworkers_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if wmworkers_entities_scan.pk is not null or wmworkers_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if wmworkers_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(wmworkers_entities_scan.pk);\n  end if;\n\n  if wmworkers_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(wmworkers_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by wmworkers_entities.partition_key, wmworkers_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        }
      },
      "version": 7
    },
    {
      "downgradeScript": "begin\n  drop function entity_buf_decode(value JSONB, name text);\n  drop function entity_buf_encode(value JSONB, name text, data text);\n  drop function encode_string_key(in_str text, OUT _result text);\n  drop function decode_string_key(in_str text, OUT _result text);\n  drop function encode_composite_key(key1 text, key2 text);\n  drop function decode_composite_key(encoded_key text);\nend\n",
      "methods": {
      },
      "migrationScript": "begin\n  -- define useful functions for migrations of tc-lib-entities tables.  These will persist and can\n  -- be used by future version files and downgrade scripts\n\n  -- given two simple keys, create a composite key like Entity.CompositeKey.\n  create or replace function encode_composite_key(key1 text, key2 text) RETURNS text\n  as $$\n      begin\n          return encode_string_key(key1) || '~' || encode_string_key(key2);\n      end;\n  $$\n  language plpgSQL\n  strict immutable;\n\n  -- Reverse the effect of encode_composite_key.  Note that SQL arrays are 1-indexed!\n  create or replace function decode_composite_key(encoded_key text) RETURNS text[]\n  as $$\n      begin\n       return array[decode_string_key(split_part(encoded_key, '~', 1)), decode_string_key(split_part(encoded_key, '~', 2))];\n      end;\n  $$\n  language plpgSQL\n  strict immutable;\n\n  -- decode the __buf encoding defined in tc-lib-entities entitytypes.js\n  create or replace function entity_buf_decode(value JSONB, name text) RETURNS text\n  as $$\n      declare\n          buffer text = '';\n          chunks integer;\n          chunk integer = 0;\n      begin\n          chunks = (value ->> ('__bufchunks_' || name))::integer;\n          loop\n              exit when chunks is null or chunk >= chunks;\n              buffer = buffer || (value ->> ('__buf' || chunk || '_' || name))::text;\n              chunk = chunk + 1;\n          end loop;\n          return convert_from(decode(buffer, 'base64'), 'utf8');\n      end;\n  $$\n  language plpgSQL\n  strict immutable;\n\n  -- encode the __buf encoding defined in tc-lib-entities entitytypes.js.  This uses a single\n  -- buffer unconditionally\n  create or replace function entity_buf_encode(value JSONB, name text, data text) RETURNS jsonb\n  as $$\n      declare\n        bytes bytea;\n      begin\n        value = jsonb_set(value,\n            ('{__bufchunks_' || name || '}')::text[],\n            to_jsonb(1));\n        bytes = convert_to(data, 'utf8');\n        value = jsonb_set(value,\n            ('{__buf0_' || name || '}')::text[],\n            to_jsonb(replace(encode(bytes, 'base64'), E'\\n', '')));\n        return value;\n      end;\n  $$\n  language plpgSQL\n  strict immutable;\n\n  -- SQL implementation of the tc-lib-entities encodeStringKey function, with credit to Nick in\n  -- https://stackoverflow.com/questions/341074/urlencode-with-only-built-in-functions\n  create or replace function encode_string_key(in_str text) returns text\n  as $$\n    select\n      case when in_str = '' then '!'\n      else\n        string_agg(\n          case\n            when ch = E'\\x5C' then '!5C'\n            when ch = '~' then '!7e'\n            when ol>1 or ch !~ '[-''()*.0-9A-Z_a-z]' \n                then regexp_replace(upper(substring(ch::bytea::text, 3)), '(..)', E'!\\\\1', 'g')\n            else ch\n          end,\n          ''\n        )\n      end\n    from (\n      select ch, octet_length(ch) as ol\n      from regexp_split_to_table($1, '') as ch\n    ) as s;\n  $$\n  language sql\n  strict immutable;\n\n  -- inverse of encode_string_key\n  -- based on https://www.postgresql.org/message-id/B6F6FD62F2624C4C9916AC0175D56D880CE1C118@jenmbs01.ad.intershop.net\n  -- with some major revisions to handle corner cases\n  create or replace function decode_string_key(in_str text) returns text\n  as $$\n    declare\n      ret text;\n      t text[];\n    begin\n      -- '!' is a special-case encoding of an empty string\n      if in_str = '!' then\n        return '';\n      end if;\n      \n      with str as (\n        select\n          -- `plain` is an array of all non-encoded substrings, including a blank first string\n          -- if necessary so that we can assume the first component is blank\n          case when in_str ~ '^![0-9a-fA-F][0-9a-fA-F]' \n            then '{}'|| regexp_split_to_array (in_str,'(![0-9a-fA-F][0-9a-fA-F])+', 'i')\n            else regexp_split_to_array (in_str,'(![0-9a-fA-F][0-9a-fA-F])+', 'i')\n           end plain,\n\n          -- `encoded` is the opposite, all encoded substrings\n          array(select (regexp_matches (in_str,'((?:![0-9a-fA-F][0-9a-fA-F])+)', 'gi'))[1]) encoded\n      )\n      -- concatentate pairs of `plain` and decoded `encoded`\n      select string_agg(plain[i] || coalesce( convert_from(decode(replace(encoded[i], '!',''), 'hex'), 'utf8'),''),'')\n          from str, \n                (select  generate_series(1, greatest(0, array_upper(encoded,1))+2) i FROM str) as i\n      into ret;\n      return ret;\n    end;\n  $$\n  language plpgsql\n  strict immutable;\nend\n",
      "version": 8
    },
    {
      "downgradeScript": "begin\n  -- lock this table before reading from it, to prevent loss of concurrent\n  -- updates when the table is dropped.\n  lock table cache_purges;\n\n  create table cache_purges_entities(\n    partition_key text, row_key text,\n    value jsonb not null,\n    version integer not null,\n    etag uuid default public.gen_random_uuid());\n  alter table cache_purges_entities add primary key (partition_key, row_key);\n\n  insert into cache_purges_entities\n  select\n    encode_composite_key(provisioner_id, worker_type) as partition_key,\n    encode_string_key(cache_name) as row_key,\n    jsonb_build_object(\n      'PartitionKey', encode_composite_key(provisioner_id, worker_type),\n      'RowKey', encode_string_key(cache_name),\n      'provisionerId', provisioner_id,\n      'workerType', worker_type,\n      'cacheName', cache_name,\n      'before', before,\n      'expires', expires) as value,\n    1 as version,\n    etag\n  from cache_purges;\n\n  revoke select, insert, update, delete on cache_purges from $db_user_prefix$_purge_cache;\n  drop table cache_purges;\n  grant select, insert, update, delete on cache_purges_entities to $db_user_prefix$_purge_cache;\n\n  drop function get_page_limit(page_size integer);\n  drop function get_page_offset(page_offset integer);\nend",
      "methods": {
        "all_purge_requests": {
          "args": "page_size_in integer, page_offset_in integer",
          "body": "begin\n  return query select cache_purges.provisioner_id, cache_purges.worker_type, cache_purges.cache_name, cache_purges.before\n  from cache_purges\n  order by cache_purges.provisioner_id, cache_purges.worker_type, cache_purges.cache_name\n  limit get_page_limit(page_size_in)\n  offset get_page_offset(page_offset_in);\nend",
          "deprecated": false,
          "description": "View all active purge requests.",
          "mode": "read",
          "returns": "table (provisioner_id text, worker_type text, cache_name text, before timestamptz)",
          "serviceName": "purge_cache"
        },
        "cache_purges_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_row cache_purges%ROWTYPE;\nbegin\n  select\n    (properties ->> 'provisionerId')::text as provisioner_id,\n    (properties ->> 'workerType')::text as worker_type,\n    (properties ->> 'cacheName')::text as cache_name,\n    (properties ->> 'before')::timestamptz as before,\n    (properties ->> 'expires')::timestamptz as expires,\n    public.gen_random_uuid() as etag\n  into new_row;\n  if overwrite then\n    raise exception 'overwrite not implemented';\n  else\n    execute 'insert into cache_purges select $1.*' using new_row;\n  end if;\n  return new_row.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "purge_cache"
        },
        "cache_purges_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "declare\n  decoded_composite_key text[];\nbegin\n  decoded_composite_key := decode_composite_key(cache_purges_entities_load.partition_key);\n  return query\n  select\n    cache_purges_entities_load.partition_key,\n    cache_purges_entities_load.row_key,\n    jsonb_build_object(\n      'PartitionKey', cache_purges_entities_load.partition_key,\n      'RowKey', cache_purges_entities_load.row_key,\n      'provisionerId', provisioner_id,\n      'workerType', worker_type,\n      'cacheName', cache_name,\n      'before', before,\n      'expires', expires) as value,\n    1 as version,\n    cache_purges.etag as etag\n  from cache_purges\n  where\n    cache_purges.provisioner_id = decoded_composite_key[1] and cache_purges.worker_type = decoded_composite_key[2] and cache_purges.cache_name = decode_string_key(cache_purges_entities_load.row_key);\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "purge_cache"
        },
        "cache_purges_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_row cache_purges%ROWTYPE;\n  decoded_composite_key text[];\nbegin\n  decoded_composite_key := decode_composite_key(cache_purges_entities_modify.partition_key);\n  select\n    (properties ->> 'provisionerId')::text as provisioner_id,\n    (properties ->> 'workerType')::text as worker_type,\n    (properties ->> 'cacheName')::text as cache_name,\n    (properties ->> 'before')::timestamptz as before,\n    (properties ->> 'expires')::timestamptz as expires,\n    public.gen_random_uuid() as etag\n  into new_row;\n  update cache_purges\n  set (\n    provisioner_id,\n    worker_type,\n    cache_name,\n    before,\n    expires,\n    etag\n  ) = (\n    new_row.provisioner_id,\n    new_row.worker_type,\n    new_row.cache_name,\n    new_row.before,\n    new_row.expires,\n    new_row.etag\n  )\n  where\n    cache_purges.provisioner_id = decoded_composite_key[1] and\n    cache_purges.worker_type = decoded_composite_key[2] and\n    cache_purges.cache_name = decode_string_key(cache_purges_entities_modify.row_key) and\n    cache_purges.etag = cache_purges_entities_modify.old_etag;\n  if found then\n    return query select new_row.etag;\n    return;\n  end if;\n  perform cache_purges.etag from cache_purges\n  where\n    cache_purges.provisioner_id = decoded_composite_key[1] and\n    cache_purges.worker_type = decoded_composite_key[2] and\n    cache_purges.cache_name = decode_string_key(cache_purges_entities_modify.row_key);\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "purge_cache"
        },
        "cache_purges_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "declare\n  decoded_composite_key text[];\nbegin\n  decoded_composite_key := decode_composite_key(cache_purges_entities_remove.partition_key);\n  return query delete from cache_purges\n  where\n    cache_purges.provisioner_id = decoded_composite_key[1] and cache_purges.worker_type = decoded_composite_key[2] and cache_purges.cache_name = decode_string_key(cache_purges_entities_remove.row_key)\n  returning cache_purges.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "purge_cache"
        },
        "cache_purges_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  cond text[];\n  exp_cond_operator text;\n  exp_cond_operand timestamptz;\n  partition_key_var text;\n  row_key_var text;\n  decoded_composite_key text[];\nbegin\n  decoded_composite_key := decode_composite_key(cache_purges_entities_scan.pk);\n  if not condition is null then\n    cond := regexp_split_to_array(condition, '\\s+');\n    exp_cond_operator := cond[4];\n    exp_cond_operand := cond[5] :: timestamptz;\n\n    return query select\n      encode_composite_key(cache_purges.provisioner_id, cache_purges.worker_type) as partition_key,\n      encode_string_key(cache_purges.cache_name) as row_key,\n      jsonb_build_object(\n        'PartitionKey', encode_composite_key(cache_purges.provisioner_id, cache_purges.worker_type),\n        'RowKey', cache_name,\n        'provisionerId', provisioner_id,\n        'workerType', worker_type,\n        'cacheName', cache_name,\n        'before', before,\n        'expires', expires\n      ) as value,\n      1 as version,\n      cache_purges.etag as etag from cache_purges\n    where\n      (cache_purges_entities_scan.pk is null or cache_purges_entities_scan.pk = decoded_composite_key[1] || '~' || decoded_composite_key[2]) and\n      (cache_purges_entities_scan.rk is null or cache_purges_entities_scan.rk = cache_name) and\n      case\n        when exp_cond_operator = '=' then expires = exp_cond_operand\n        when exp_cond_operator = '<' then expires < exp_cond_operand\n        when exp_cond_operator = '<=' then expires <= exp_cond_operand\n        when exp_cond_operator = '>' then expires > exp_cond_operand\n        when exp_cond_operator = '>=' then expires >= exp_cond_operand\n        else expires <> exp_cond_operand\n      end\n    order by cache_purges.provisioner_id, cache_purges.worker_type, cache_purges.cache_name\n    limit case\n      when (size is not null and size > 0) then size + 1\n      else null\n    end\n    offset case\n      when (page is not null and page > 0) then page\n      else 0\n    end;\n  else\n    return query select\n      encode_composite_key(cache_purges.provisioner_id, cache_purges.worker_type) as partition_key,\n      encode_string_key(cache_purges.cache_name) as row_key,\n      jsonb_build_object(\n        'PartitionKey', encode_composite_key(cache_purges.provisioner_id, cache_purges.worker_type),\n        'RowKey', encode_string_key(cache_name),\n        'provisionerId', provisioner_id,\n        'workerType', worker_type,\n        'cacheName', cache_name,\n        'before', before,\n        'expires', expires\n      ) as value,\n      1 as version,\n      cache_purges.etag as etag from cache_purges\n    where\n      (cache_purges_entities_scan.pk is null or (cache_purges.provisioner_id = decoded_composite_key[1] and cache_purges.worker_type = decoded_composite_key[2])) and\n      (cache_purges_entities_scan.rk is null or cache_purges_entities_scan.rk = cache_name)\n    order by cache_purges.provisioner_id, cache_purges.worker_type, cache_purges.cache_name\n    limit case\n      when (size is not null and size > 0) then size + 1\n      else null\n    end\n    offset case\n      when (size is not null and size > 0 and page is not null and page > 0) then page\n      else 0\n    end;\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "purge_cache"
        },
        "expire_cache_purges": {
          "args": "expires_in timestamptz",
          "body": "declare\n  count integer;\nbegin\n  delete from cache_purges where cache_purges.expires < expires_in;\n  if found then\n    get diagnostics count = row_count;\n    return count;\n  end if;\n  return 0;\nend",
          "deprecated": false,
          "description": "Expire cache purges that come before `expires_in`.\nReturns a count of rows that have been deleted.",
          "mode": "write",
          "returns": "integer",
          "serviceName": "purge_cache"
        },
        "purge_cache": {
          "args": "provisioner_id_in text, worker_type_in text, cache_name_in text, before_in timestamptz, expires_in timestamptz",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  insert into cache_purges(provisioner_id, worker_type, cache_name, before, expires, etag)\n  values (\n    provisioner_id_in,\n    worker_type_in,\n    cache_name_in,\n    before_in,\n    expires_in,\n    new_etag\n  ) on conflict (provisioner_id, worker_type, cache_name) do\n  update\n  set (before, expires, etag) = (before_in, expires_in, new_etag)\n  where cache_purges.provisioner_id = provisioner_id_in and cache_purges.worker_type = worker_type_in and cache_purges.cache_name = cache_name_in;\nend",
          "deprecated": false,
          "description": "Publish a request to purge caches with name `cache_name_in`\non `provisioner_id_in`/`worker_type_in` workers.",
          "mode": "write",
          "returns": "void",
          "serviceName": "purge_cache"
        },
        "purge_requests": {
          "args": "provisioner_id_in text, worker_type_in text",
          "body": "begin\n  return query\n  select cache_purges.provisioner_id, cache_purges.worker_type, cache_purges.cache_name, cache_purges.before from cache_purges\n  where cache_purges.provisioner_id = provisioner_id_in and cache_purges.worker_type = worker_type_in;\nend",
          "deprecated": false,
          "description": "List the caches for this `provisioner_id_in`/`worker_type_in`.",
          "mode": "read",
          "returns": "table (provisioner_id text, worker_type text, cache_name text, before timestamptz)",
          "serviceName": "purge_cache"
        }
      },
      "migrationScript": "begin\n  -- lock this table before reading from it, to prevent loss of concurrent\n  -- updates when the table is dropped.  Note that this may lead to concurrent\n  -- updates failing; the important thing is that they not succeed without\n  -- taking effect.  Failed updates will be retried.\n  lock table cache_purges_entities;\n\n  create table cache_purges\n  as\n    select\n      (value ->> 'provisionerId')::text as provisioner_id,\n      (value ->> 'workerType')::text as worker_type,\n      (value ->> 'cacheName')::text as cache_name,\n      (value ->> 'before')::timestamptz as before,\n      (value ->> 'expires')::timestamptz as expires,\n      etag\n    from cache_purges_entities;\n  alter table cache_purges add primary key (provisioner_id, worker_type, cache_name);\n  alter table cache_purges\n    alter column provisioner_id set not null,\n    alter column worker_type set not null,\n    alter column cache_name set not null,\n    alter column before set not null,\n    alter column expires set not null,\n    alter column etag set not null,\n    alter column etag set default public.gen_random_uuid();\n\n  revoke select, insert, update, delete on cache_purges_entities from $db_user_prefix$_purge_cache;\n  drop table cache_purges_entities;\n  grant select, insert, update, delete on cache_purges to $db_user_prefix$_purge_cache;\n\n  -- Given a page size it returns the limit to use on a paginated db function.\n  create or replace function get_page_limit(page_size integer) RETURNS integer\n  as $$\n      begin\n        return case\n          when (page_size is not null and page_size > 0) then page_size\n          else null\n        end;\n      end;\n  $$\n  language plpgSQL\n  strict immutable;\n\n  -- Given a page offset it returns the offset to use on a paginated db function.\n  create or replace function get_page_offset(page_offset integer) RETURNS integer\n  as $$\n      begin\n        return case\n          when (page_offset is not null and page_offset > 0) then page_offset\n          else 0\n        end;\n      end;\n  $$\n  language plpgSQL\n  strict immutable;\nend",
      "version": 9
    },
    {
      "downgradeScript": "begin\n  -- lock this table before reading from it, to prevent loss of concurrent\n  -- updates when the table is dropped.\n  lock table worker_pools;\n\n  create table wmworker_pools_entities(\n    partition_key text, row_key text,\n    value jsonb not null,\n    version integer not null,\n    etag uuid default public.gen_random_uuid());\n  alter table wmworker_pools_entities add primary key (partition_key, row_key);\n\n  insert into wmworker_pools_entities\n  select\n    encode_string_key(worker_pool_id) as partition_key,\n    'workerPool' as row_key,\n    entity_buf_encode(\n      entity_buf_encode(\n        entity_buf_encode(\n          jsonb_build_object(\n            'PartitionKey', encode_string_key(worker_pool_id),\n            'RowKey', 'workerPool',\n            'workerPoolId', worker_pool_id,\n            'providerId', provider_id,\n            'owner', owner,\n            'description', description,\n            'emailOnError', email_on_error,\n            'created', created,\n            'lastModified', last_modified),\n          'config', config::text),\n        'providerData', provider_data::text),\n      'previousProviderIds', previous_provider_ids::text) as value,\n    1 as version,\n    etag\n  from worker_pools;\n\n  revoke select, insert, update, delete on worker_pools from $db_user_prefix$_worker_manager;\n  drop table worker_pools;\n  grant select, insert, update, delete on wmworker_pools_entities to $db_user_prefix$_worker_manager;\nend\n",
      "methods": {
        "create_worker_pool": {
          "args": "worker_pool_id_in text, provider_id_in text, previous_provider_ids_in jsonb, description_in text, config_in jsonb, created_in timestamptz, last_modified_in timestamptz, owner_in text, email_on_error_in boolean, provider_data_in jsonb",
          "body": "begin\n  insert\n    into worker_pools (worker_pool_id, provider_id, previous_provider_ids, description, config, created, last_modified, owner, email_on_error, provider_data)\n    values (worker_pool_id_in, provider_id_in, previous_provider_ids_in, description_in, config_in, created_in, last_modified_in, owner_in, email_on_error_in, provider_data_in);\nend",
          "deprecated": false,
          "description": "Create a new worker pool.  Raises UNIQUE_VIOLATION if the pool already exists.",
          "mode": "write",
          "returns": "void",
          "serviceName": "worker_manager"
        },
        "delete_worker_pool": {
          "args": "worker_pool_id_in text",
          "body": "begin\n  delete\n  from worker_pools\n  where worker_pools.worker_pool_id = worker_pool_id_in;\nend",
          "deprecated": false,
          "description": "Delete a worker pool immediately.",
          "mode": "write",
          "returns": "void",
          "serviceName": "worker_manager"
        },
        "expire_worker_pools": {
          "args": "",
          "body": "begin\n  return query delete\n  from worker_pools\n  where worker_pools.provider_id = 'null-provider'\n  and worker_pools.previous_provider_ids = '[]'::jsonb\n  returning worker_pools.worker_pool_id;\nend",
          "deprecated": false,
          "description": "Expire worker pools, deleting those which have provider-id null-provider and\nno previous_provider_ids.  Returns the worker pool ids that it deletes.",
          "mode": "write",
          "returns": "table(worker_pool_id text)",
          "serviceName": "worker_manager"
        },
        "get_worker_pool": {
          "args": "worker_pool_id_in text",
          "body": "begin\n  return query\n  select\n    worker_pools.worker_pool_id,\n    worker_pools.provider_id,\n    worker_pools.previous_provider_ids,\n    worker_pools.description,\n    worker_pools.config,\n    worker_pools.created,\n    worker_pools.last_modified,\n    worker_pools.owner,\n    worker_pools.email_on_error,\n    worker_pools.provider_data\n  from worker_pools\n  where worker_pools.worker_pool_id = worker_pool_id_in;\nend",
          "deprecated": false,
          "description": "Get an existig worker pool.  The returned table will have one or (if no such worker pool is defined) zero rows.",
          "mode": "read",
          "returns": "table(worker_pool_id text, provider_id text, previous_provider_ids jsonb, description text, config jsonb, created timestamptz, last_modified timestamptz, owner text, email_on_error boolean, provider_data jsonb)",
          "serviceName": "worker_manager"
        },
        "get_worker_pools": {
          "args": "page_size_in integer, page_offset_in integer",
          "body": "begin\n  return query\n  select\n    worker_pools.worker_pool_id,\n    worker_pools.provider_id,\n    worker_pools.previous_provider_ids,\n    worker_pools.description,\n    worker_pools.config,\n    worker_pools.created,\n    worker_pools.last_modified,\n    worker_pools.owner,\n    worker_pools.email_on_error,\n    worker_pools.provider_data\n  from worker_pools\n  order by worker_pool_id\n  limit get_page_limit(page_size_in)\n  offset get_page_offset(page_offset_in);\nend",
          "deprecated": false,
          "description": "Get existing worker pools, ordered by `worker_pool_id`.  If the pagination arguments are both NULL, all rows are returned.\nOtherwise, page_size rows are returned at offset page_offset.",
          "mode": "read",
          "returns": "table(worker_pool_id text, provider_id text, previous_provider_ids jsonb, description text, config jsonb, created timestamptz, last_modified timestamptz, owner text, email_on_error boolean, provider_data jsonb)",
          "serviceName": "worker_manager"
        },
        "remove_worker_pool_previous_provider_id": {
          "args": "worker_pool_id_in text, provider_id_in text",
          "body": "begin\n  update worker_pools\n  set\n    previous_provider_ids = previous_provider_ids - provider_id_in\n  where\n    worker_pool_id = worker_pool_id_in;\nend",
          "deprecated": false,
          "description": "Remove the given provider_id from the worker pool's previous_provider_ids.  It is\nnot an error if the worker pool does not exist, or if the provider_id is not in the\nprevious_provider_ids set.",
          "mode": "write",
          "returns": "void",
          "serviceName": "worker_manager"
        },
        "update_worker_pool": {
          "args": "worker_pool_id_in text, provider_id_in text, description_in text, config_in jsonb, last_modified_in timestamptz, owner_in text, email_on_error_in boolean",
          "body": "declare\n  existing record;\nbegin\n  select\n    worker_pools.provider_id,\n    worker_pools.previous_provider_ids\n  from worker_pools\n  where worker_pools.worker_pool_id = worker_pool_id_in\n  -- lock this row for the duration of this transaction..\n  for update\n  into existing;\n\n  -- update previous_provider_ids, if the provider_id has changed\n  if existing.provider_id <> provider_id_in then\n    -- remove both provider IDs to avoid duplicates, then re-add existing.provider_id\n    existing.previous_provider_ids = (existing.previous_provider_ids - provider_id_in - existing.provider_id) || jsonb_build_array(existing.provider_id);\n  end if;\n\n  return query update worker_pools\n  set\n    provider_id = provider_id_in,\n    description = description_in,\n    config = config_in,\n    last_modified = last_modified_in,\n    owner = owner_in,\n    email_on_error = email_on_error_in,\n    previous_provider_ids = existing.previous_provider_ids\n  where worker_pools.worker_pool_id = worker_pool_id_in\n  returning\n    worker_pools.worker_pool_id,\n    worker_pools.provider_id,\n    worker_pools.description,\n    worker_pools.config,\n    worker_pools.created,\n    worker_pools.last_modified,\n    worker_pools.owner,\n    worker_pools.email_on_error,\n    existing.provider_id as previous_provider_id;\nend",
          "deprecated": false,
          "description": "Update API-accessible columns on an existing worker pool.  All fields are\noverridden, but if the provider_id changes, then the existing provider_id\nis added to previous_provider_ids.  The return value contains values\nrequired for an API response and previous_provider_id (singular) containing\nthe provider_id found before the update.  If no such worker pool exists,\nthe return value is an empty set.",
          "mode": "write",
          "returns": "table(worker_pool_id text, provider_id text, description text, config jsonb, created timestamptz, last_modified timestamptz, owner text, email_on_error boolean, previous_provider_id text)",
          "serviceName": "worker_manager"
        },
        "update_worker_pool_provider_data": {
          "args": "worker_pool_id_in text, provider_id_in text, provider_data_in jsonb",
          "body": "begin\n  update worker_pools\n  set\n    provider_data = provider_data || jsonb_build_object(provider_id_in, provider_data_in)\n  where\n    worker_pool_id = worker_pool_id_in;\nend",
          "deprecated": false,
          "description": "Update the provider_data for the given provider_id in this worker pool.  Note that\nthis sets the provider_data property unconditionally, and it is up to the service\nto ensure that concurrent modifications do not occur.  It is not an error if the\nworker pool does not exist.",
          "mode": "write",
          "returns": "void",
          "serviceName": "worker_manager"
        },
        "wmworker_pools_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_row worker_pools%ROWTYPE;\nbegin\n  select\n    (properties ->> 'workerPoolId')::text as worker_pool_id,\n    (properties ->> 'providerId')::text as provider_id,\n    (properties ->> 'owner')::text as owner,\n    (properties ->> 'description')::text as description,\n    (properties -> 'emailOnError')::boolean as email_on_error,\n    (properties ->> 'created')::timestamptz as created,\n    (properties ->> 'lastModified')::timestamptz as last_modified,\n    entity_buf_decode(properties, 'config')::jsonb as config,\n    entity_buf_decode(properties, 'providerData')::jsonb as provider_data,\n    entity_buf_decode(properties, 'previousProviderIds')::jsonb as previous_provider_ids,\n    public.gen_random_uuid() as etag\n  into new_row;\n  if overwrite then\n    raise exception 'overwrite not implemented';\n  else\n    execute 'insert into worker_pools select $1.*' using new_row;\n  end if;\n  return new_row.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "worker_manager"
        },
        "wmworker_pools_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select\n    wmworker_pools_entities_load.partition_key,\n    'workerPool' as row_key,\n    entity_buf_encode(\n      entity_buf_encode(\n        entity_buf_encode(\n          jsonb_build_object(\n            'PartitionKey', wmworker_pools_entities_load.partition_key,\n            'RowKey', 'workerPool',\n            'workerPoolId', worker_pool_id,\n            'providerId', provider_id,\n            'owner', owner,\n            'description', description,\n            'emailOnError', email_on_error,\n            'created', created,\n            'lastModified', last_modified),\n          'config', config::text),\n        'providerData', provider_data::text),\n      'previousProviderIds', previous_provider_ids::text) as value,\n    1 as version,\n    worker_pools.etag as etag\n  from worker_pools\n  where\n    worker_pools.worker_pool_id = decode_string_key(wmworker_pools_entities_load.partition_key);\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pools_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_row worker_pools%ROWTYPE;\nbegin\n  select\n    (properties ->> 'workerPoolId')::text as worker_pool_id,\n    (properties ->> 'providerId')::text as provider_id,\n    (properties ->> 'owner')::text as owner,\n    (properties ->> 'description')::text as description,\n    (properties -> 'emailOnError')::boolean as email_on_error,\n    (properties ->> 'created')::timestamptz as created,\n    (properties ->> 'lastModified')::timestamptz as last_modified,\n    entity_buf_decode(properties, 'config')::jsonb as config,\n    entity_buf_decode(properties, 'providerData')::jsonb as provider_data,\n    entity_buf_decode(properties, 'previousProviderIds')::jsonb as previous_provider_ids,\n    public.gen_random_uuid() as etag\n  into new_row;\n  update worker_pools\n  set (\n    provider_id,\n    owner,\n    description,\n    email_on_error,\n    created,\n    last_modified,\n    config,\n    provider_data,\n    previous_provider_ids,\n    etag\n  ) = (\n    new_row.provider_id,\n    new_row.owner,\n    new_row.description,\n    new_row.email_on_error,\n    new_row.created,\n    new_row.last_modified,\n    new_row.config,\n    new_row.provider_data,\n    new_row.previous_provider_ids,\n    new_row.etag\n  )\n  where\n    worker_pools.worker_pool_id = decode_string_key(wmworker_pools_entities_modify.partition_key) and\n    worker_pools.etag = wmworker_pools_entities_modify.old_etag;\n\n  if found then\n    return query select new_row.etag;\n    return;\n  end if;\n\n  perform worker_pools.etag from worker_pools\n  where worker_pools.worker_pool_id = decode_string_key(wmworker_pools_entities_modify.partition_key);\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pools_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  delete\n  from worker_pools\n  where\n    worker_pools.worker_pool_id = decode_string_key(partition_key);\n  -- worker-manager does not care if the row existed\n  return query select gen_random_uuid() as etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pools_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\nbegin\n  if not condition is null then\n    raise exception 'condition not supported';\n  end if;\n  return query\n    select\n      wmworker_pools_entities_scan.partition_key,\n      'workerPool' as row_key,\n      entity_buf_encode(\n        entity_buf_encode(\n          entity_buf_encode(\n            jsonb_build_object(\n              'PartitionKey', encode_string_key(worker_pool_id),\n              'RowKey', 'workerPool',\n              'workerPoolId', worker_pool_id,\n              'providerId', provider_id,\n              'owner', owner,\n              'description', description,\n              'emailOnError', email_on_error,\n              'created', created,\n              'lastModified', last_modified),\n            'config', config::text),\n          'providerData', provider_data::text),\n        'previousProviderIds', previous_provider_ids::text) as value,\n      1 as version,\n    worker_pools.etag as etag\n    from worker_pools\n    where\n      partition_key is null or\n      worker_pool_id = decode_string_key(partition_key)\n    order by worker_pool_id\n    limit size + 1\n    offset page;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        }
      },
      "migrationScript": "begin\n  -- decode the __buf encoding defined in tc-lib-entities entitytypes.js.\n  -- This is a re-definition of the function from DB version 8, where it incorrectly\n  -- handled rows with more than one buffer.\n  create or replace function entity_buf_decode(value JSONB, name text) RETURNS text\n  as $$\n      declare\n          buffer text = '';\n          chunks integer;\n          chunk integer = 0;\n      begin\n          chunks = (value ->> ('__bufchunks_' || name))::integer;\n          loop\n              exit when chunks is null or chunk >= chunks;\n              buffer = buffer || convert_from(decode((value ->> ('__buf' || chunk || '_' || name))::text, 'base64'), 'utf8');\n              chunk = chunk + 1;\n          end loop;\n          return buffer;\n      end;\n  $$\n  language plpgSQL\n  strict immutable;\n\n  -- lock this table before reading from it, to prevent loss of concurrent\n  -- updates when the table is dropped.  Note that this may lead to concurrent\n  -- updates failing; the important thing is that they not succeed without\n  -- taking effect.  Failed updates will be retried.\n  lock table wmworker_pools_entities;\n\n  create table worker_pools\n  as\n    select\n      (value ->> 'workerPoolId')::text as worker_pool_id,\n      (value ->> 'providerId')::text as provider_id,\n      (value ->> 'owner')::text as owner,\n      (value ->> 'description')::text as description,\n      (value -> 'emailOnError')::boolean as email_on_error,\n      (value ->> 'created')::timestamptz as created,\n      (value ->> 'lastModified')::timestamptz as last_modified,\n      entity_buf_decode(value, 'config')::jsonb as config,\n      entity_buf_decode(value, 'providerData')::jsonb as provider_data,\n      entity_buf_decode(value, 'previousProviderIds')::jsonb as previous_provider_ids,\n      etag\n    from wmworker_pools_entities;\n  alter table worker_pools add primary key (worker_pool_id);\n  alter table worker_pools\n    alter column provider_id set not null,\n    alter column owner set not null,\n    alter column description set not null,\n    alter column email_on_error set not null,\n    alter column created set not null,\n    alter column last_modified set not null,\n    alter column config set not null,\n    alter column provider_data set not null,\n    alter column previous_provider_ids set not null,\n    alter column etag set not null,\n    alter column etag set default public.gen_random_uuid();\n\n  revoke select, insert, update, delete on wmworker_pools_entities from $db_user_prefix$_worker_manager;\n  drop table wmworker_pools_entities;\n  grant select, insert, update, delete on worker_pools to $db_user_prefix$_worker_manager;\nend\n",
      "version": 10
    },
    {
      "downgradeScript": "begin\n  create table widgets (\n    name text\n  );\n  grant select, insert, update, delete on widgets to $db_user_prefix$_notify;\nend",
      "methods": {
        "update_widgets": {
          "args": "name_in text",
          "body": "begin\n  return;\nend",
          "deprecated": false,
          "description": "Temporary method to test infrastructure support fo database access",
          "mode": "write",
          "returns": "table (name text)",
          "serviceName": "notify"
        }
      },
      "migrationScript": "begin\n  revoke select, insert, update, delete on widgets from $db_user_prefix$_notify;\n  drop table widgets;\nend",
      "version": 11
    },
    {
      "downgradeScript": "begin\n  -- lock this table before reading from it, to prevent loss of concurrent\n  -- updates when the table is dropped.\n  lock table workers;\n\n  create table wmworkers_entities(\n    partition_key text, row_key text,\n    value jsonb not null,\n    version integer not null,\n    etag uuid default public.gen_random_uuid());\n  alter table wmworkers_entities add primary key (partition_key, row_key);\n\n  insert into wmworkers_entities\n  select\n    encode_string_key(worker_pool_id) as partition_key,\n    encode_composite_key(worker_group, worker_id) as row_key,\n    entity_buf_encode(\n        jsonb_build_object(\n          'PartitionKey', encode_string_key(worker_pool_id),\n          'RowKey', 'workerPool',\n          'workerPoolId', worker_pool_id,\n          'workerGroup', worker_group,\n          'workerId', worker_id,\n          'providerId', provider_id,\n          'created', created,\n          'expires', expires,\n          'state', state,\n          'capacity', capacity,\n          'lastModified', last_modified,\n          'lastChecked', last_checked),\n        'providerData', provider_data::text) as value,\n    1 as version,\n    etag\n  from workers;\n\n  revoke select, insert, update, delete on workers from $db_user_prefix$_worker_manager;\n  drop table workers;\n  grant select, insert, update, delete on wmworkers_entities to $db_user_prefix$_worker_manager;\nend",
      "methods": {
        "create_worker": {
          "args": "worker_pool_id_in text, worker_group_in text, worker_id_in text, provider_id_in text, created_in timestamptz, expires_in timestamptz, state_in text, provider_data_in jsonb, capacity_in integer, last_modified_in timestamptz, last_checked_in timestamptz",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  insert\n    into workers (worker_pool_id, worker_group, worker_id, provider_id, created, expires, state, provider_data, capacity, last_modified, last_checked, etag)\n    values (worker_pool_id_in, worker_group_in, worker_id_in, provider_id_in, created_in, expires_in, state_in, provider_data_in, capacity_in, last_modified_in, last_checked_in, new_etag);\n\n  return new_etag;\nend",
          "deprecated": false,
          "description": "Create a new worker. Raises UNIQUE_VIOLATION if the worker already exists.\nReturns the etag of the newly created worker.",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "worker_manager"
        },
        "delete_worker": {
          "args": "worker_pool_id_in text, worker_group_in text, worker_id_in text",
          "body": "begin\n  delete\n  from workers\n  where\n    workers.worker_pool_id = worker_pool_id_in and\n    workers.worker_group = worker_group_in and\n    workers.worker_id = worker_id_in;\nend",
          "deprecated": false,
          "description": "Delete a worker.",
          "mode": "write",
          "returns": "void",
          "serviceName": "worker_manager"
        },
        "expire_workers": {
          "args": "expires_in timestamptz",
          "body": "declare\n  count integer;\nbegin\n  delete from workers where workers.expires < expires_in;\n  if found then\n    get diagnostics count = row_count;\n    return count;\n  end if;\n  return 0;\nend",
          "deprecated": false,
          "description": "Expire workers that come before `expires_in`.\nReturns a count of rows that have been deleted.",
          "mode": "write",
          "returns": "integer",
          "serviceName": "worker_manager"
        },
        "get_worker": {
          "args": "worker_pool_id_in text, worker_group_in text, worker_id_in text",
          "body": "begin\n  return query\n  select\n    workers.worker_pool_id,\n    workers.worker_group,\n    workers.worker_id,\n    workers.provider_id,\n    workers.created,\n    workers.expires,\n    workers.state,\n    workers.provider_data,\n    workers.capacity,\n    workers.last_modified,\n    workers.last_checked,\n    workers.etag\n  from workers\n  where\n    workers.worker_pool_id = worker_pool_id_in and\n    workers.worker_group = worker_group_in and\n    workers.worker_id = worker_id_in;\nend",
          "deprecated": false,
          "description": "Get an existing worker. The returned table will have one or (if no such worker is defined) zero rows.",
          "mode": "read",
          "returns": "table(worker_pool_id text, worker_group text, worker_id text, provider_id text, created timestamptz, expires timestamptz, state text, provider_data jsonb, capacity integer, last_modified timestamptz, last_checked timestamptz, etag uuid)",
          "serviceName": "worker_manager"
        },
        "get_workers": {
          "args": "worker_pool_id_in text, worker_group_in text, worker_id_in text, state_in text, page_size_in integer, page_offset_in integer",
          "body": "begin\n  return query\n  select\n    workers.worker_pool_id,\n    workers.worker_group,\n    workers.worker_id,\n    workers.provider_id,\n    workers.created,\n    workers.expires,\n    workers.state,\n    workers.provider_data,\n    workers.capacity,\n    workers.last_modified,\n    workers.last_checked\n  from workers\n  where\n    (workers.worker_pool_id = worker_pool_id_in or worker_pool_id_in is null) and\n    (workers.worker_group = worker_group_in or worker_group_in is null) and\n    (workers.worker_id = worker_id_in or worker_id_in is null) and\n    (workers.state = state_in or state_in is null)\n  order by worker_pool_id, worker_group, worker_id\n  limit get_page_limit(page_size_in)\n  offset get_page_offset(page_offset_in);\nend",
          "deprecated": false,
          "description": "Get existing workers filtered by the optional arguments,\nordered by `worker_pool_id`, `worker_group`, and  `worker_id`.\nIf the pagination arguments are both NULL, all rows are returned.\nOtherwise, page_size rows are returned at offset page_offset.",
          "mode": "read",
          "returns": "table(worker_pool_id text, worker_group text, worker_id text, provider_id text, created timestamptz, expires timestamptz, state text, provider_data jsonb, capacity integer, last_modified timestamptz, last_checked timestamptz)",
          "serviceName": "worker_manager"
        },
        "update_worker": {
          "args": "worker_pool_id_in text, worker_group_in text, worker_id_in text, provider_id_in text, created_in timestamptz, expires_in timestamptz, state_in text, provider_data_in jsonb, capacity_in integer, last_modified_in timestamptz, last_checked_in timestamptz, etag_in uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\n  updated_row workers%ROWTYPE;\nbegin\n  update workers\n  set (provider_id, created, expires, state, provider_data, capacity, last_modified, last_checked, etag) = (\n    coalesce(provider_id_in, workers.provider_id),\n    coalesce(created_in, workers.created),\n    coalesce(expires_in, workers.expires),\n    coalesce(state_in, workers.state),\n    coalesce(provider_data_in, workers.provider_data),\n    coalesce(capacity_in, workers.capacity),\n    coalesce(last_modified_in, workers.last_modified),\n    coalesce(last_checked_in, workers.last_checked),\n    new_etag\n  )\n  where\n    workers.worker_pool_id = worker_pool_id_in and\n    workers.worker_group = worker_group_in and\n    workers.worker_id = worker_id_in and\n    workers.etag = coalesce(etag_in, workers.etag)\n  returning\n    workers.worker_pool_id,\n    workers.worker_group,\n    workers.worker_id,\n    workers.provider_id,\n    workers.created,\n    workers.expires,\n    workers.state,\n    workers.provider_data,\n    workers.capacity,\n    workers.last_modified,\n    workers.last_checked,\n    workers.etag\n  into updated_row;\n\n  if found then\n    return query select\n      updated_row.worker_pool_id,\n      updated_row.worker_group,\n      updated_row.worker_id,\n      updated_row.provider_id,\n      updated_row.created,\n      updated_row.expires,\n      updated_row.state,\n      updated_row.provider_data,\n      updated_row.capacity,\n      updated_row.last_modified,\n      updated_row.last_checked,\n      updated_row.etag;\n    return;\n  end if;\n\n  perform workers.etag from workers\n    where\n      workers.worker_pool_id = worker_pool_id_in and\n      workers.worker_group = worker_group_in and\n      workers.worker_id = worker_id_in;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "Update a worker.\nReturns the up-to-date worker row that have the same worker_pool_id, worker_group, and worker_id.\nIf the etag argument is empty then the update will overwrite the matched row.\nElse, the function will fail if the etag is out of date. This is useful for concurency handling.",
          "mode": "write",
          "returns": "table(worker_pool_id text, worker_group text, worker_id text, provider_id text, created timestamptz, expires timestamptz, state text, provider_data jsonb, capacity integer, last_modified timestamptz, last_checked timestamptz, etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworkers_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_row workers%ROWTYPE;\nbegin\n  select\n    (properties ->> 'workerPoolId')::text,\n    (properties ->> 'workerGroup')::text,\n    (properties ->> 'workerId')::text,\n    (properties ->> 'providerId')::text,\n    (properties ->> 'created')::timestamptz,\n    (properties ->> 'expires')::timestamptz,\n    (properties ->> 'state')::text,\n    entity_buf_decode(properties, 'providerData')::jsonb,\n    (properties ->> 'capacity')::integer as capacity,\n    (properties ->> 'lastModified')::timestamptz,\n    (properties ->> 'lastChecked')::timestamptz,\n    public.gen_random_uuid()\n  into new_row;\n  if overwrite then\n    raise exception 'overwrite not implemented';\n  else\n    execute 'insert into workers select $1.*' using new_row;\n  end if;\n  return new_row.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "worker_manager"
        },
        "wmworkers_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "declare\n  decoded_composite_key text[];\nbegin\n  decoded_composite_key := decode_composite_key(wmworkers_entities_load.row_key);\n  return query\n  select\n    wmworkers_entities_load.partition_key,\n    wmworkers_entities_load.row_key,\n    entity_buf_encode(\n      jsonb_build_object(\n        'PartitionKey', encode_string_key(worker_pool_id),\n        'RowKey', encode_composite_key(worker_group, worker_id),\n        'workerPoolId', worker_pool_id,\n        'workerGroup', worker_group,\n        'workerId', worker_id,\n        'providerId', provider_id,\n        'created', created,\n        'expires', expires,\n        'state', state,\n        'capacity', capacity,\n        'lastModified', last_modified,\n        'lastChecked', last_checked),\n      'providerData', provider_data::text) as value,\n    1 as version,\n    workers.etag as etag\n  from workers\n  where\n    workers.worker_pool_id = decode_string_key(wmworkers_entities_load.partition_key) and workers.worker_group = decoded_composite_key[1] and workers.worker_id = decoded_composite_key[2];\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworkers_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_row workers%ROWTYPE;\n  decoded_composite_key text[];\nbegin\n  decoded_composite_key := decode_composite_key(wmworkers_entities_modify.row_key);\n  select\n    (properties ->> 'workerPoolId')::text,\n    (properties ->> 'workerGroup')::text,\n    (properties ->> 'workerId')::text,\n    (properties ->> 'providerId')::text,\n    (properties ->> 'created')::timestamptz,\n    (properties ->> 'expires')::timestamptz,\n    (properties ->> 'state')::text,\n    entity_buf_decode(properties, 'providerData')::jsonb,\n    (properties ->> 'capacity')::integer,\n    (properties ->> 'lastModified')::timestamptz,\n    (properties ->> 'lastChecked')::timestamptz,\n    public.gen_random_uuid() as etag\n  into new_row;\n  update workers\n  set (\n    provider_id,\n    created,\n    expires,\n    state,\n    capacity,\n    last_modified,\n    last_checked,\n    provider_data,\n    etag\n  ) = (\n    new_row.provider_id,\n    new_row.created,\n    new_row.expires,\n    new_row.state,\n    new_row.capacity,\n    new_row.last_modified,\n    new_row.last_checked,\n    new_row.provider_data,\n    new_row.etag\n  )\n  where\n    workers.worker_pool_id = decode_string_key(wmworkers_entities_modify.partition_key) and\n    workers.worker_group = decoded_composite_key[1] and\n    workers.worker_id = decoded_composite_key[2] and\n    workers.etag = wmworkers_entities_modify.old_etag;\n  if found then\n    return query select new_row.etag;\n    return;\n  end if;\n  perform workers.etag from workers\n  where\n    workers.worker_pool_id = decode_string_key(wmworkers_entities_modify.partition_key) and\n    workers.worker_group = decoded_composite_key[1] and\n    workers.worker_id = decoded_composite_key[2];\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworkers_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "declare\n  decoded_composite_key text[];\nbegin\n  decoded_composite_key := decode_composite_key(wmworkers_entities_remove.row_key);\n  return query delete from workers\n  where\n    workers.worker_pool_id = decode_string_key(wmworkers_entities_remove.partition_key) and\n    workers.worker_group = decoded_composite_key[1] and\n    workers.worker_id = decoded_composite_key[2]\n  returning workers.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworkers_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  cond text[];\n  exp_cond_operator text;\n  exp_cond_operand timestamptz;\n  partition_key_var text;\n  row_key_var text;\n  decoded_composite_key text[];\nbegin\n  decoded_composite_key := decode_composite_key(wmworkers_entities_scan.rk);\n  if not condition is null then\n    cond := regexp_split_to_array(condition, '\\s+');\n    exp_cond_operator := cond[4];\n    exp_cond_operand := cond[5] :: timestamptz;\n\n    return query select\n      encode_string_key(worker_pool_id) as partition_key,\n      encode_composite_key(worker_group, worker_id) as row_key,\n      entity_buf_encode(\n        jsonb_build_object(\n          'PartitionKey', encode_string_key(worker_pool_id),\n          'RowKey', encode_composite_key(worker_group, worker_id),\n          'workerPoolId', worker_pool_id,\n          'workerGroup', worker_group,\n          'workerId', worker_id,\n          'providerId', provider_id,\n          'created', created,\n          'expires', expires,\n          'state', state,\n          'capacity', capacity,\n          'lastModified', last_modified,\n          'lastChecked', last_checked),\n        'providerData', provider_data::text) as value,\n      1 as version,\n      workers.etag as etag from workers\n    where\n      (wmworkers_entities_scan.pk is null or decode_string_key(wmworkers_entities_scan.pk) = worker_pool_id) and\n      (wmworkers_entities_scan.rk is null or wmworkers_entities_scan.rk = decoded_composite_key[1] || '~' || decoded_composite_key[2]) and\n      case\n        when exp_cond_operator = '=' then expires = exp_cond_operand\n        when exp_cond_operator = '<' then expires < exp_cond_operand\n        when exp_cond_operator = '<=' then expires <= exp_cond_operand\n        when exp_cond_operator = '>' then expires > exp_cond_operand\n        when exp_cond_operator = '>=' then expires >= exp_cond_operand\n        else expires <> exp_cond_operand\n      end\n    order by workers.worker_pool_id, workers.worker_group, workers.worker_id\n    limit case\n      when (size is not null and size > 0) then size + 1\n      else null\n    end\n    offset case\n      when (page is not null and page > 0) then page\n      else 0\n    end;\n  else\n    return query select\n      encode_string_key(worker_pool_id) as partition_key,\n      encode_composite_key(worker_group, worker_id) as row_key,\n      entity_buf_encode(\n        jsonb_build_object(\n          'PartitionKey', encode_string_key(worker_pool_id),\n          'RowKey', encode_composite_key(worker_group, worker_id),\n          'workerPoolId', worker_pool_id,\n          'workerGroup', worker_group,\n          'workerId', worker_id,\n          'providerId', provider_id,\n          'created', created,\n          'expires', expires,\n          'state', state,\n          'capacity', capacity,\n          'lastModified', last_modified,\n          'lastChecked', last_checked),\n        'providerData', provider_data::text) as value,\n      1 as version,\n      workers.etag as etag from workers\n    where\n      (wmworkers_entities_scan.pk is null or decode_string_key(wmworkers_entities_scan.pk) = worker_pool_id) and\n      (wmworkers_entities_scan.rk is null or (worker_group = decoded_composite_key[1] and worker_id = decoded_composite_key[2]))\n    order by workers.worker_pool_id, workers.worker_group, workers.worker_id\n    limit case\n      when (size is not null and size > 0) then size + 1\n      else null\n    end\n    offset case\n      when (size is not null and size > 0 and page is not null and page > 0) then page\n      else 0\n    end;\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        }
      },
      "migrationScript": "begin\n  -- lock this table before reading from it, to prevent loss of concurrent\n  -- updates when the table is dropped.  Note that this may lead to concurrent\n  -- updates failing; the important thing is that they not succeed without\n  -- taking effect.  Failed updates will be retried.\n  lock table wmworkers_entities;\n\n  create table workers\n  as\n    select\n      (value ->> 'workerPoolId')::text as worker_pool_id,\n      (value ->> 'workerGroup')::text as worker_group,\n      (value ->> 'workerId')::text as worker_id,\n      (value ->> 'providerId')::text as provider_id,\n      (value ->> 'created')::timestamptz as created,\n      (value ->> 'expires')::timestamptz as expires,\n      (value ->> 'state')::text as state,\n      entity_buf_decode(value, 'providerData')::jsonb as provider_data,\n      (value ->> 'capacity')::integer as capacity,\n      (value ->> 'lastModified')::timestamptz as last_modified,\n      (value ->> 'lastChecked')::timestamptz as last_checked,\n      etag\n    from wmworkers_entities;\n  alter table workers add primary key (worker_pool_id, worker_group, worker_id);\n  alter table workers\n    alter column worker_pool_id set not null,\n    alter column worker_group set not null,\n    alter column worker_id set not null,\n    alter column provider_id set not null,\n    alter column created set not null,\n    alter column expires set not null,\n    alter column state set not null,\n    alter column provider_data set not null,\n    alter column capacity set not null,\n    alter column last_modified set not null,\n    alter column last_checked set not null,\n    alter column etag set not null,\n    alter column etag set default public.gen_random_uuid();\n\n  revoke select, insert, update, delete on wmworkers_entities from $db_user_prefix$_worker_manager;\n  drop table wmworkers_entities;\n  grant select, insert, update, delete on workers to $db_user_prefix$_worker_manager;\nend",
      "version": 12
    },
    {
      "methods": {
        "get_worker_pool": {
          "deprecated": true
        },
        "get_worker_pool_with_capacity": {
          "args": "worker_pool_id_in text",
          "body": "begin\n  return query\n  select\n    worker_pools.worker_pool_id,\n    worker_pools.provider_id,\n    worker_pools.previous_provider_ids,\n    worker_pools.description,\n    worker_pools.config,\n    worker_pools.created,\n    worker_pools.last_modified,\n    worker_pools.owner,\n    worker_pools.email_on_error,\n    worker_pools.provider_data,\n    coalesce((\n      select sum(workers.capacity) from workers where\n        workers.worker_pool_id = worker_pool_id_in and\n        workers.state != 'stopped'),\n      0)::integer -- sum always wants to return a bigint but we're always going to be safely within integer range\n  from worker_pools\n  where worker_pools.worker_pool_id = worker_pool_id_in;\nend",
          "deprecated": false,
          "description": "Get an existing worker pool.  The returned table will have one or (if no such worker pool is defined) zero rows.",
          "mode": "read",
          "returns": "table(worker_pool_id text, provider_id text, previous_provider_ids jsonb, description text, config jsonb, created timestamptz, last_modified timestamptz, owner text, email_on_error boolean, provider_data jsonb, current_capacity integer)",
          "serviceName": "worker_manager"
        },
        "get_worker_pools": {
          "deprecated": true
        },
        "get_worker_pools_with_capacity": {
          "args": "page_size_in integer, page_offset_in integer",
          "body": "begin\n  return query\n  select\n    worker_pools.worker_pool_id,\n    worker_pools.provider_id,\n    worker_pools.previous_provider_ids,\n    worker_pools.description,\n    worker_pools.config,\n    worker_pools.created,\n    worker_pools.last_modified,\n    worker_pools.owner,\n    worker_pools.email_on_error,\n    worker_pools.provider_data,\n    coalesce(sum(worker_capacities.capacity), 0)::integer -- sum always wants to return a bigint but we're always going to be safely within integer range\n  from worker_pools\n  left join (\n    select workers.worker_pool_id, workers.capacity from workers\n      where workers.state != 'stopped'\n  ) as worker_capacities\n  on worker_pools.worker_pool_id = worker_capacities.worker_pool_id\n  group by worker_pools.worker_pool_id\n  order by worker_pools.worker_pool_id\n  limit get_page_limit(page_size_in)\n  offset get_page_offset(page_offset_in);\nend",
          "deprecated": false,
          "description": "Get existing worker pools, ordered by `worker_pool_id`.  If the pagination arguments are both NULL, all rows are returned.\nOtherwise, page_size rows are returned at offset page_offset.",
          "mode": "read",
          "returns": "table(worker_pool_id text, provider_id text, previous_provider_ids jsonb, description text, config jsonb, created timestamptz, last_modified timestamptz, owner text, email_on_error boolean, provider_data jsonb, current_capacity integer)",
          "serviceName": "worker_manager"
        },
        "update_worker_pool": {
          "deprecated": true
        },
        "update_worker_pool_with_capacity": {
          "args": "worker_pool_id_in text, provider_id_in text, description_in text, config_in jsonb, last_modified_in timestamptz, owner_in text, email_on_error_in boolean",
          "body": "declare\n  existing record;\nbegin\n  select\n    worker_pools.provider_id,\n    worker_pools.previous_provider_ids\n  from worker_pools\n  where worker_pools.worker_pool_id = worker_pool_id_in\n  -- lock this row for the duration of this transaction..\n  for update\n  into existing;\n\n  -- update previous_provider_ids, if the provider_id has changed\n  if existing.provider_id <> provider_id_in then\n    -- remove both provider IDs to avoid duplicates, then re-add existing.provider_id\n    existing.previous_provider_ids = (existing.previous_provider_ids - provider_id_in - existing.provider_id) || jsonb_build_array(existing.provider_id);\n  end if;\n\n  return query update worker_pools\n  set\n    provider_id = provider_id_in,\n    description = description_in,\n    config = config_in,\n    last_modified = last_modified_in,\n    owner = owner_in,\n    email_on_error = email_on_error_in,\n    previous_provider_ids = existing.previous_provider_ids\n  where worker_pools.worker_pool_id = worker_pool_id_in\n  returning\n    worker_pools.worker_pool_id,\n    worker_pools.provider_id,\n    worker_pools.description,\n    worker_pools.config,\n    worker_pools.created,\n    worker_pools.last_modified,\n    worker_pools.owner,\n    worker_pools.email_on_error,\n    existing.provider_id as previous_provider_id,\n    coalesce((\n      select sum(workers.capacity) from workers where\n        workers.worker_pool_id = worker_pool_id_in and\n        workers.state != 'stopped'),\n      0)::integer; -- sum always wants to return a bigint but we're always going to be safely within integer range\nend",
          "deprecated": false,
          "description": "Update API-accessible columns on an existig worker pool.  All fields are\noverridden, but if the provider_id changes, then the existing provider_id\nis added to previous_provider_ids.  The return value contains values\nrequired for an API response and previous_provider_id (singular) containing\nthe provider_id found before the update.  If no such worker pool exists,\nthe return value is an empty set.",
          "mode": "write",
          "returns": "table(worker_pool_id text, provider_id text, description text, config jsonb, created timestamptz, last_modified timestamptz, owner text, email_on_error boolean, previous_provider_id text, current_capacity integer)",
          "serviceName": "worker_manager"
        }
      },
      "version": 13
    },
    {
      "downgradeScript": "begin\n  alter table workers\n    drop column secret;\nend\n",
      "methods": {
        "get_worker_2": {
          "args": "worker_pool_id_in text, worker_group_in text, worker_id_in text",
          "body": "begin\n  return query\n  select\n    workers.worker_pool_id,\n    workers.worker_group,\n    workers.worker_id,\n    workers.provider_id,\n    workers.created,\n    workers.expires,\n    workers.state,\n    workers.provider_data,\n    workers.capacity,\n    workers.last_modified,\n    workers.last_checked,\n    workers.secret,\n    workers.etag\n  from workers\n  where\n    workers.worker_pool_id = worker_pool_id_in and\n    workers.worker_group = worker_group_in and\n    workers.worker_id = worker_id_in;\nend",
          "deprecated": false,
          "description": "Get an existing worker. The returned table will have one or (if no such worker is defined) zero rows.",
          "mode": "read",
          "returns": "table(worker_pool_id text, worker_group text, worker_id text, provider_id text, created timestamptz, expires timestamptz, state text, provider_data jsonb, capacity integer, last_modified timestamptz, last_checked timestamptz, secret jsonb, etag uuid)",
          "serviceName": "worker_manager"
        },
        "update_worker_2": {
          "args": "worker_pool_id_in text, worker_group_in text, worker_id_in text, provider_id_in text, created_in timestamptz, expires_in timestamptz, state_in text, provider_data_in jsonb, capacity_in integer, last_modified_in timestamptz, last_checked_in timestamptz, etag_in uuid, secret_in jsonb",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\n  updated_row workers%ROWTYPE;\nbegin\n  update workers\n  set (provider_id, created, expires, state, provider_data, capacity, last_modified, last_checked, etag, secret) = (\n    coalesce(provider_id_in, workers.provider_id),\n    coalesce(created_in, workers.created),\n    coalesce(expires_in, workers.expires),\n    coalesce(state_in, workers.state),\n    coalesce(provider_data_in, workers.provider_data),\n    coalesce(capacity_in, workers.capacity),\n    coalesce(last_modified_in, workers.last_modified),\n    coalesce(last_checked_in, workers.last_checked),\n    new_etag,\n    coalesce(secret_in, workers.secret)\n  )\n  where\n    workers.worker_pool_id = worker_pool_id_in and\n    workers.worker_group = worker_group_in and\n    workers.worker_id = worker_id_in and\n    workers.etag = coalesce(etag_in, workers.etag)\n  returning\n    workers.worker_pool_id,\n    workers.worker_group,\n    workers.worker_id,\n    workers.provider_id,\n    workers.created,\n    workers.expires,\n    workers.state,\n    workers.provider_data,\n    workers.capacity,\n    workers.last_modified,\n    workers.last_checked,\n    workers.etag,\n    workers.secret\n  into updated_row;\n\n  if found then\n    return query select\n      updated_row.worker_pool_id,\n      updated_row.worker_group,\n      updated_row.worker_id,\n      updated_row.provider_id,\n      updated_row.created,\n      updated_row.expires,\n      updated_row.state,\n      updated_row.provider_data,\n      updated_row.capacity,\n      updated_row.last_modified,\n      updated_row.last_checked,\n      updated_row.etag,\n      updated_row.secret;\n    return;\n  end if;\n\n  perform workers.etag from workers\n    where\n      workers.worker_pool_id = worker_pool_id_in and\n      workers.worker_group = worker_group_in and\n      workers.worker_id = worker_id_in;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "Update a worker.\nReturns the up-to-date worker row that have the same worker_pool_id, worker_group, and worker_id.\nIf the etag argument is empty then the update will overwrite the matched row.\nElse, the function will fail if the etag is out of date. This is useful for concurency handling.",
          "mode": "write",
          "returns": "table(worker_pool_id text, worker_group text, worker_id text, provider_id text, created timestamptz, expires timestamptz, state text, provider_data jsonb, capacity integer, last_modified timestamptz, last_checked timestamptz, etag uuid, secret jsonb)",
          "serviceName": "worker_manager"
        }
      },
      "migrationScript": "begin\n  -- In an effort to support worker reregistration, an encrypted secret column is required.\n  -- https://github.com/taskcluster/taskcluster/issues/3011\n  alter table workers\n    add column secret jsonb default null;\nend\n",
      "version": 14
    },
    {
      "downgradeScript": "begin\n  drop function sha512(t text);\nend",
      "methods": {
      },
      "migrationScript": "begin\n  -- Compute the sha512 of the given text data.\n  -- sha512 is the algorithm that will be used to generate the hash.\n  -- This replaces Entity.keys.HashKey from taskcluster-lib-entities.\n  create or replace function sha512(t text) returns text\n  as $$\n      begin\n        return encode(digest(t, 'sha512'), 'hex');\n      end;\n  $$\n  language plpgSQL\n  strict immutable;\nend\n",
      "version": 15
    },
    {
      "downgradeScript": "begin\n  drop function uuid_to_slugid(uuid text);\n  drop function slugid_to_uuid(slugid text);\nend\n",
      "methods": {
      },
      "migrationScript": "begin\n  -- SlugIDs are stored as UUIDs in Azure, because Azure stores that efficiently, but this makes it\n  -- difficult to query the DB since everywhere else we deal with SlugIDs in their 22-character\n  -- representation.  So these functions convert uuids to slugids and back.  Refer to\n  -- https://github.com/taskcluster/slugid/blob/53ec9a2de7140afff5b986c7c60a8028512e87d0/slugid.js\n  create or replace function uuid_to_slugid(uuid text) RETURNS text\n  as $$\n    begin\n      return left(replace(replace(encode(decode(replace(uuid, '-', ''), 'hex'), 'base64'), '+', '-'), '/', '_'), 22);\n    end;\n  $$\n  language plpgSQL\n  strict immutable;\n\n  create or replace function slugid_to_uuid(slugid text) RETURNS text\n  as $$\n    begin\n      return (encode(decode(replace(replace(slugid, '_', '/'), '-', '+') || '==', 'base64') , 'hex')::uuid)::text;\n    end;\n  $$\n  language plpgSQL\n  strict immutable;\nend\n",
      "version": 16
    }
  ]
}